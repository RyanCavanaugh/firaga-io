import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

declare const JSZip: any;

export function generateOpenSCADMasks(image: PartListImage, filename: string): void {
    loadJSZipAnd(() => generateOpenSCADMasksWorker(image, filename));
}

async function loadJSZipAnd(func: () => void) {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        const tag = document.createElement("script");
        tag.id = tagName;
        tag.onload = () => {
            func();
        };
        tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        document.head.appendChild(tag);
    } else {
        func();
    }
}

function generateOpenSCADMasksWorker(image: PartListImage, filename: string): void {
    const zip = new JSZip();

    // Generate mask images for each color
    const masks: Array<{ name: string; dataUrl: string; color: string }> = [];
    
    image.partList.forEach((part, partIndex) => {
        if (part.count === 0) return;

        const maskCanvas = createMaskCanvas(image, partIndex);
        const dataUrl = maskCanvas.toDataURL('image/png');
        const colorHex = colorEntryToHex(part.target);
        const maskName = `mask_${part.symbol}_${part.target.name.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
        
        masks.push({ name: maskName, dataUrl, color: colorHex });

        // Add image to zip (remove data URL prefix)
        const base64Data = dataUrl.split(',')[1];
        zip.file(maskName, base64Data, { base64: true });
    });

    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, masks);
    zip.file(`${filename}.scad`, scadContent);

    // Generate and download zip file
    zip.generateAsync({ type: 'blob' }).then((blob: Blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}_openscad.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });
}

function createMaskCanvas(image: PartListImage, partIndex: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;

    // Fill with white background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, image.width, image.height);

    // Draw black pixels where this color appears
    ctx.fillStyle = 'black';
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            if (image.pixels[y][x] === partIndex) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }

    return canvas;
}

function generateOpenSCADFile(
    image: PartListImage,
    masks: Array<{ name: string; dataUrl: string; color: string }>
): string {
    let scad = `// Generated by firaga.io
// Image size: ${image.width}x${image.height}
// This file uses surface() to create 3D heightmaps from mask images

pixel_size = 1;
base_height = 0.5;
layer_height = 1;

`;

    // Create a module for each color using surface() with the mask images
    masks.forEach((mask, index) => {
        const part = image.partList.find(p => p.count > 0 && masks[index]?.name.includes(p.symbol));
        const colorName = part?.target.name.replace(/[^a-zA-Z0-9]/g, '_') || `color_${index}`;
        const colorHex = mask.color;

        scad += `// ${part?.target.name || 'Unknown'} (${part?.symbol || '?'}) - ${colorHex}
module layer_${colorName}() {
    color("${colorHex}") {
        translate([0, 0, ${index} * layer_height]) {
            // Use the mask image as a heightmap
            // Black pixels (value 0) will be at height 0
            // White pixels (value 255) will be at the scaled height
            scale([pixel_size, pixel_size, base_height]) {
                surface(file = "${mask.name}", center = true, invert = true);
            }
        }
    }
}

`;
    });

    // Union all layers
    scad += `// Combine all layers
union() {
`;
    masks.forEach((mask, index) => {
        const part = image.partList.find(p => p.count > 0 && masks[index]?.name.includes(p.symbol));
        const colorName = part?.target.name.replace(/[^a-zA-Z0-9]/g, '_') || `color_${index}`;
        scad += `    layer_${colorName}();
`;
    });
    scad += `}
`;

    return scad;
}
