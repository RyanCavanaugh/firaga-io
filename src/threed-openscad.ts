import { PartListImage } from "./image-utils";
import { saveAs } from "file-saver";

// Import JSZip dynamically
declare const JSZip: any;

/**
 * Generate and download a ZIP file containing:
 * - One monochrome mask image per color (black/white PNG)
 * - An OpenSCAD file that loads all masks and combines them into a 3D display
 */
export async function generateOpenSCADMasks(image: PartListImage, filename: string): Promise<void> {
    await loadJSZip();
    
    const { width, height, pixels, partList } = image;
    
    // Create a new ZIP file
    const zip = new JSZip();
    
    // Generate mask images for each color
    const maskFiles: string[] = [];
    
    for (let colorIndex = 0; colorIndex < partList.length; colorIndex++) {
        const entry = partList[colorIndex];
        const maskFilename = `mask_${colorIndex}_${sanitizeFilename(entry.target.name)}.png`;
        maskFiles.push(maskFilename);
        
        // Create black/white mask
        const maskData = createMaskImage(pixels, width, height, colorIndex);
        zip.file(maskFilename, maskData);
    }
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(maskFiles, partList, width, height);
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate the ZIP and trigger download
    const blob = await zip.generateAsync({ type: "blob" });
    saveAs(blob, `${filename}_openscad.zip`);
}

function createMaskImage(
    pixels: ReadonlyArray<ReadonlyArray<number>>,
    width: number,
    height: number,
    colorIndex: number
): Blob {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    
    if (!ctx) {
        throw new Error("Could not get canvas context");
    }
    
    const imageData = ctx.createImageData(width, height);
    
    // Fill with black/white based on whether pixel matches color
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const offset = (y * width + x) * 4;
            const isMatch = pixels[y][x] === colorIndex;
            const color = isMatch ? 255 : 0; // White for match, black for no match
            
            imageData.data[offset] = color;     // R
            imageData.data[offset + 1] = color; // G
            imageData.data[offset + 2] = color; // B
            imageData.data[offset + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Convert canvas to blob
    return new Promise<Blob>((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error("Failed to create blob from canvas"));
            }
        }, "image/png");
    }) as any;
}

function generateOpenSCADFile(
    maskFiles: string[],
    partList: ReadonlyArray<{ target: { name: string; r: number; g: number; b: number } }>,
    width: number,
    height: number
): string {
    const layers: string[] = [];
    
    maskFiles.forEach((maskFile, index) => {
        const entry = partList[index];
        const r = entry.target.r / 255;
        const g = entry.target.g / 255;
        const b = entry.target.b / 255;
        
        layers.push(`
// ${entry.target.name}
color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
translate([0, 0, ${index}])
surface(file = "${maskFile}", center = true, invert = true);`);
    });
    
    const scadContent = `// Generated by firaga.io
// Pixel art 3D model from heightmap masks
// Image size: ${width}x${height}

// Scale factor for the model (adjust as needed)
scale_factor = 1;

scale([scale_factor, scale_factor, scale_factor]) {
${layers.join('\n')}
}
`;
    
    return scadContent;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    
    // Check if already loaded
    if (typeof JSZip !== "undefined") {
        return;
    }
    
    // Load JSZip from CDN
    return new Promise<void>((resolve, reject) => {
        const scriptEl = document.getElementById(tagName);
        if (scriptEl === null) {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error("Failed to load JSZip"));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        } else {
            resolve();
        }
    });
}
