import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

/**
 * Generates an OpenSCAD masks format export.
 * Creates a ZIP file containing:
 * - One monochrome (black/white) PNG image per color
 * - An OpenSCAD file (.scad) that loads images as heightmaps
 */
export function generateOpenScadMasks(image: PartListImage, filename: string): void {
    const files: Array<{ name: string; content: Blob }> = [];
    
    // Generate one mask image per color
    const scadParts: string[] = [];
    scadParts.push('// Generated by firaga.io');
    scadParts.push('// OpenSCAD heightmap display');
    scadParts.push('');
    scadParts.push('pixel_size = 1; // Size of each pixel in mm');
    scadParts.push('height_scale = 1; // Height of the display');
    scadParts.push('');
    
    for (let i = 0; i < image.partList.length; i++) {
        const part = image.partList[i];
        if (!part) continue;
        
        // Create a black and white mask for this color
        const maskCanvas = createMaskCanvas(image, i);
        const maskFilename = `mask_${i}_${sanitizeFilename(part.target.name)}.png`;
        
        // Convert canvas to blob
        maskCanvas.toBlob((blob) => {
            if (blob) {
                files.push({ name: maskFilename, content: blob });
            }
        }, 'image/png');
        
        // Add OpenSCAD code for this layer
        const colorHex = colorEntryToHex(part.target);
        const rgb = hexToRgb(colorHex);
        
        scadParts.push(`// Layer ${i}: ${part.target.name}`);
        scadParts.push(`color([${rgb.r / 255}, ${rgb.g / 255}, ${rgb.b / 255}])`);
        scadParts.push(`  surface(file="${maskFilename}", center=true, invert=true);`);
        scadParts.push('');
    }
    
    scadParts.push('// Combine all layers');
    scadParts.push('union() {');
    for (let i = 0; i < image.partList.length; i++) {
        const part = image.partList[i];
        if (!part) continue;
        scadParts.push(`  // ${part.target.name}`);
    }
    scadParts.push('}');
    
    const scadContent = scadParts.join('\n');
    const scadBlob = new Blob([scadContent], { type: 'text/plain' });
    files.push({ name: `${filename}.scad`, content: scadBlob });
    
    // Wait a bit for all canvas.toBlob operations to complete
    setTimeout(() => {
        createZipAndDownload(files, `${filename}_openscad.zip`);
    }, 500);
}

/**
 * Creates a black and white canvas mask for a specific color/part index
 */
function createMaskCanvas(image: PartListImage, partIndex: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas 2D context');
    }
    
    // Fill with white (empty)
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw black pixels where this color appears
    ctx.fillStyle = '#000000';
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            if (image.pixels[y][x] === partIndex) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    return canvas;
}

/**
 * Creates a simple ZIP file from the given files and triggers download
 * This is a basic implementation without external dependencies
 */
function createZipAndDownload(files: Array<{ name: string; content: Blob }>, zipFilename: string): void {
    // For now, download files individually if we don't have a ZIP library
    // In a production environment, you would use JSZip library
    
    // Simple workaround: create a downloadable link for each file
    // Or use a ZIP library like JSZip if available
    
    if (files.length === 0) {
        console.error('No files to zip');
        return;
    }
    
    // Try to use JSZip if it's loaded globally
    const JSZip = (window as any).JSZip;
    
    if (JSZip) {
        const zip = new JSZip();
        
        for (const file of files) {
            zip.file(file.name, file.content);
        }
        
        zip.generateAsync({ type: 'blob' }).then((content: Blob) => {
            downloadBlob(content, zipFilename);
        });
    } else {
        // Fallback: download files individually
        console.warn('JSZip not available, downloading files individually');
        for (const file of files) {
            downloadBlob(file.content, file.name);
        }
    }
}

function downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
}
