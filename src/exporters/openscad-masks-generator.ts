import { PartListImage } from '../image-utils';
import { colorEntryToHex } from '../utils';
import { Export3DProps } from '../types';
import { saveAs } from 'file-saver';

export function generateOpenSCADMasks(image: PartListImage, filename: string, settings: Export3DProps): void {
    const { layerHeight, pixelWidth, pixelHeight } = settings;
    
    // Generate one PNG per color
    const pngFiles = new Map<string, Blob>();
    
    image.partList.forEach((part, colorIdx) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d');
        
        if (!ctx) return;
        
        // Create black and white mask
        const imageData = ctx.createImageData(image.width, image.height);
        
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                const idx = (y * image.width + x) * 4;
                const isThisColor = image.pixels[y][x] === colorIdx;
                const value = isThisColor ? 0 : 255; // Black for filled, white for empty
                
                imageData.data[idx] = value;     // R
                imageData.data[idx + 1] = value; // G
                imageData.data[idx + 2] = value; // B
                imageData.data[idx + 3] = 255;   // A
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Convert to blob
        canvas.toBlob((blob) => {
            if (blob) {
                const colorName = sanitizeFilename(part.target.name);
                pngFiles.set(`${colorName}.png`, blob);
            }
        });
    });
    
    // Generate OpenSCAD file
    const scadContent = generateSCADFile(image, layerHeight, pixelWidth, pixelHeight);
    const scadBlob = new Blob([scadContent], { type: 'text/plain' });
    
    // Create zip file containing all PNGs and the SCAD file
    // Wait for all blobs to be created
    setTimeout(() => {
        createZipFile(pngFiles, scadBlob, filename);
    }, 100);
}

function generateSCADFile(image: PartListImage, layerHeight: number, pixelWidth: number, pixelHeight: number): string {
    let scad = `// Generated by firaga.io
// Image dimensions: ${image.width}x${image.height}
// Pixel size: ${pixelWidth}mm x ${pixelHeight}mm
// Layer height: ${layerHeight}mm

pixel_width = ${pixelWidth};
pixel_height = ${pixelHeight};
layer_height = ${layerHeight};

union() {
`;
    
    image.partList.forEach((part, idx) => {
        const colorName = sanitizeFilename(part.target.name);
        const color = colorEntryToHex(part.target).substring(1); // Remove #
        const r = parseInt(color.substring(0, 2), 16) / 255;
        const g = parseInt(color.substring(2, 4), 16) / 255;
        const b = parseInt(color.substring(4, 6), 16) / 255;
        
        scad += `  // ${part.target.name} (${part.count} pixels)
  color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
  translate([0, 0, ${idx * layerHeight}])
  surface(file = "${colorName}.png", center = true, invert = true, convexity = 10)
  scale([pixel_width, pixel_height, layer_height]);
  
`;
    });
    
    scad += `}
`;
    
    return scad;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9-_]/g, '_');
}

function createZipFile(pngFiles: Map<string, Blob>, scadBlob: Blob, filename: string): void {
    // This is a simplified implementation
    // In a real implementation, you would use JSZip to create a proper ZIP file
    // For now, we'll just save the SCAD file separately
    
    // TODO: Implement proper ZIP creation with JSZip
    // For the moment, save the SCAD file and inform user to manually create structure
    saveAs(scadBlob, `${filename}.scad`);
    
    // Save each PNG
    let idx = 0;
    for (const [name, blob] of pngFiles.entries()) {
        setTimeout(() => {
            saveAs(blob, `${filename}_${name}`);
        }, idx * 100);
        idx++;
    }
}
