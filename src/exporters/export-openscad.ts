import { PartListImage } from '../image-utils';
import { saveAs } from 'file-saver';

declare const JSZip: any;

export async function exportOpenSCADMasks(image: PartListImage, filename: string) {
    await loadJSZip();
    
    const zip = new JSZip();
    const baseFilename = filename.replace(/\.[^.]+$/, '');
    
    // Generate a mask image for each color
    for (let idx = 0; idx < image.partList.length; idx++) {
        const part = image.partList[idx];
        const maskImage = await generateMaskImage(image, idx);
        zip.file(`mask_${idx}_${sanitizeFilename(part.target.name)}.png`, maskImage);
    }
    
    // Generate the OpenSCAD file
    const scadContent = generateOpenSCADFile(image, baseFilename);
    zip.file(`${baseFilename}.scad`, scadContent);
    
    // Generate the zip file
    const blob = await zip.generateAsync({ type: 'blob' });
    saveAs(blob, `${baseFilename}_openscad.zip`);
}

function generateMaskImage(image: PartListImage, colorIndex: number): Promise<Blob> {
    // Create a canvas to generate the mask
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    // Fill the image data - white where the color matches, black elsewhere
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const pixelColorIdx = image.pixels[y][x];
            const isMatch = pixelColorIdx === colorIndex;
            const value = isMatch ? 255 : 0;
            
            const offset = (y * image.width + x) * 4;
            imageData.data[offset] = value;     // R
            imageData.data[offset + 1] = value; // G
            imageData.data[offset + 2] = value; // B
            imageData.data[offset + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Convert canvas to blob
    return new Promise<Blob>((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob from canvas'));
            }
        }, 'image/png');
    });
}

function generateOpenSCADFile(image: PartListImage, baseFilename: string): string {
    let scad = `// OpenSCAD file for ${baseFilename}
// Generated by firaga.io

// Image dimensions
width = ${image.width};
height = ${image.height};
layer_height = 1; // Height of each color layer

`;

    // Generate color definitions with RGB values
    scad += '// Color definitions\n';
    image.partList.forEach((part, idx) => {
        const r = part.target.r / 255;
        const g = part.target.g / 255;
        const b = part.target.b / 255;
        scad += `color_${idx} = [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}]; // ${part.target.name}\n`;
    });
    scad += '\n';

    // Generate the heightmap surface for each color
    scad += '// Generate 3D model from color masks\n';
    scad += 'union() {\n';
    
    image.partList.forEach((part, idx) => {
        const maskFilename = `mask_${idx}_${sanitizeFilename(part.target.name)}.png`;
        scad += `    // Layer for ${part.target.name}\n`;
        scad += `    color(color_${idx})\n`;
        scad += `    translate([0, 0, ${idx * 0.1}])\n`;
        scad += `    surface(file = "${maskFilename}", center = true, invert = true);\n`;
        scad += '\n';
    });
    
    scad += '}\n';
    
    return scad;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    
    if (typeof JSZip !== 'undefined') {
        return Promise.resolve();
    }
    
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        return new Promise((resolve, reject) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error('Failed to load JSZip'));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
    
    return Promise.resolve();
}
