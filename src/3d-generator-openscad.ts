import { PartListImage } from "./image-utils";
import { ThreeDSettings } from "./3d-generator-3mf";
import { saveAs } from "file-saver";

export function generateOpenSCADMasks(image: PartListImage, settings: ThreeDSettings) {
    // For OpenSCAD masks, we need to create a zip file
    // Since we don't have jszip, we'll implement a simple inline solution
    // Generate masks as data URLs and create the .scad file
    
    const files: { name: string, content: string | Uint8Array }[] = [];
    
    // Create a monochrome PNG for each color
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const color = image.partList[colorIndex];
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, image.width, image.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = 'black';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIndex) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert to PNG blob
        const dataURL = canvas.toDataURL('image/png');
        const colorName = sanitizeFilename(color.target.name || `color_${colorIndex}`);
        files.push({
            name: `${colorName}.png`,
            content: dataURL
        });
    }
    
    // Create the OpenSCAD file
    const scadContent = generateSCADFile(image, settings);
    files.push({
        name: `${settings.filename}.scad`,
        content: scadContent
    });
    
    // Create a simple zip file
    createZipAndDownload(files, `${settings.filename}_openscad.zip`);
}

function generateSCADFile(image: PartListImage, settings: ThreeDSettings): string {
    const pixelSize = settings.pitch;
    const layerHeight = settings.pitch * 0.5;
    
    const colorLayers: string[] = [];
    
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const color = image.partList[colorIndex];
        const colorName = sanitizeFilename(color.target.name || `color_${colorIndex}`);
        const r = color.target.r / 255;
        const g = color.target.g / 255;
        const b = color.target.b / 255;
        
        colorLayers.push(`
    // ${color.target.name}
    color([${r}, ${g}, ${b}])
    scale([${pixelSize}, ${pixelSize}, ${layerHeight}])
    surface(file = "${colorName}.png", center = false, invert = true);`);
    }
    
    const scadContent = `// Generated by firaga.io
// 3D representation of pixel art image
// Each color is a separate layer

union() {
${colorLayers.join('\n')}
}
`;
    
    return scadContent;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

async function createZipAndDownload(files: { name: string, content: string | Uint8Array }[], filename: string) {
    // Since we don't have JSZip installed, we'll need to add it
    // For now, let's use a workaround: download files individually or use a minimal zip implementation
    
    // Try to dynamically load JSZip from CDN
    const JSZip = await loadJSZip();
    
    const zip = new JSZip();
    
    for (const file of files) {
        if (typeof file.content === 'string') {
            if (file.content.startsWith('data:')) {
                // It's a data URL, extract the base64 part
                const base64Data = file.content.split(',')[1];
                zip.file(file.name, base64Data, { base64: true });
            } else {
                zip.file(file.name, file.content);
            }
        } else {
            zip.file(file.name, file.content);
        }
    }
    
    const blob = await zip.generateAsync({ type: 'blob' });
    
    // Use file-saver to download
    saveAs(blob, filename);
}

async function loadJSZip(): Promise<any> {
    // Check if JSZip is already loaded
    if ((window as any).JSZip) {
        return (window as any).JSZip;
    }
    
    // Load JSZip from CDN
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        script.onload = () => {
            resolve((window as any).JSZip);
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
}
