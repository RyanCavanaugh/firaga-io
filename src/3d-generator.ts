import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export type ThreeDFormat = "3mf" | "openscad";

export interface ThreeDSettings {
    format: ThreeDFormat;
    pixelHeight: number;
    pixelSize: number;
    filename: string;
}

export async function generate3D(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    if (settings.format === "3mf") {
        await generate3MF(image, settings);
    } else {
        await generateOpenSCADMasks(image, settings);
    }
}

async function generate3MF(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const meshes: string[] = [];
    let nextObjectId = 2;
    const materialDefs: string[] = [];
    const materialRefs: string[] = [];

    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const part = image.partList[colorIdx];
        const color = part.target;
        const materialId = colorIdx + 1;
        
        const hexColor = colorEntryToHex(color).substring(1);
        materialDefs.push(
            `  <basematerials id="${materialId}">`,
            `   <base name="${color.name}" displaycolor="#${hexColor}" />`,
            `  </basematerials>`
        );

        const vertices: Array<{ x: number; y: number; z: number }> = [];
        const triangles: Array<{ v1: number; v2: number; v3: number }> = [];

        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    addCube(
                        x * settings.pixelSize,
                        y * settings.pixelSize,
                        0,
                        settings.pixelSize,
                        settings.pixelSize,
                        settings.pixelHeight,
                        vertices,
                        triangles
                    );
                }
            }
        }

        if (vertices.length > 0) {
            const verticesStr = vertices
                .map(v => `   <vertex x="${v.x}" y="${v.y}" z="${v.z}" />`)
                .join('\n');
            const trianglesStr = triangles
                .map(t => `   <triangle v1="${t.v1}" v2="${t.v2}" v3="${t.v3}" />`)
                .join('\n');

            meshes.push(
                ` <mesh>`,
                `  <vertices>`,
                verticesStr,
                `  </vertices>`,
                `  <triangles>`,
                trianglesStr,
                `  </triangles>`,
                ` </mesh>`
            );

            materialRefs.push(
                ` <object id="${nextObjectId}" type="model" pid="${materialId}" pindex="0">`,
                meshes[meshes.length - 1],
                ` </object>`
            );
            nextObjectId++;
        }
    }

    const buildItems = materialRefs
        .map((_, idx) => `  <item objectid="${idx + 2}" />`)
        .join('\n');

    const xml = [
        '<?xml version="1.0" encoding="UTF-8"?>',
        '<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">',
        ' <resources>',
        ...materialDefs,
        ...materialRefs,
        ' </resources>',
        ' <build>',
        buildItems,
        ' </build>',
        '</model>'
    ].join('\n');

    downloadAsFile(`${settings.filename}.3mf`, xml, 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml');
}

function addCube(
    x: number, y: number, z: number,
    width: number, depth: number, height: number,
    vertices: Array<{ x: number; y: number; z: number }>,
    triangles: Array<{ v1: number; v2: number; v3: number }>
): void {
    const baseIdx = vertices.length;
    
    vertices.push(
        { x, y, z },
        { x: x + width, y, z },
        { x: x + width, y: y + depth, z },
        { x, y: y + depth, z },
        { x, y, z: z + height },
        { x: x + width, y, z: z + height },
        { x: x + width, y: y + depth, z: z + height },
        { x, y: y + depth, z: z + height }
    );

    const faces = [
        [0, 1, 2, 3], // bottom
        [4, 7, 6, 5], // top
        [0, 4, 5, 1], // front
        [1, 5, 6, 2], // right
        [2, 6, 7, 3], // back
        [3, 7, 4, 0]  // left
    ];

    for (const face of faces) {
        const [a, b, c, d] = face.map(i => baseIdx + i);
        triangles.push({ v1: a, v2: b, v3: c });
        triangles.push({ v1: a, v2: c, v3: d });
    }
}

async function generateOpenSCADMasks(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const JSZip = (await import('jszip')).default;
    const zip = new JSZip();

    const scadLines: string[] = [
        '// Generated by firaga.io',
        `pixel_size = ${settings.pixelSize};`,
        `pixel_height = ${settings.pixelHeight};`,
        '',
    ];

    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const part = image.partList[colorIdx];
        const filename = `color_${colorIdx}_${sanitizeFilename(part.target.name)}.png`;
        
        const imageData = createMaskImage(image, colorIdx);
        const pngBlob = await canvasToPngBlob(imageData);
        zip.file(filename, pngBlob);

        const hexColor = colorEntryToHex(part.target).substring(1);
        scadLines.push(
            `// ${part.target.name}`,
            `color("#${hexColor}")`,
            `translate([0, 0, ${colorIdx * settings.pixelHeight}])`,
            `scale([pixel_size, pixel_size, pixel_height])`,
            `surface(file = "${filename}", center = true, invert = true);`,
            ''
        );
    }

    zip.file('model.scad', scadLines.join('\n'));

    const blob = await zip.generateAsync({ type: 'blob' });
    downloadBlob(`${settings.filename}_openscad.zip`, blob);
}

function createMaskImage(image: PartListImage, colorIdx: number): ImageData {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }

    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const isColor = image.pixels[y][x] === colorIdx;
            const value = isColor ? 255 : 0;
            
            imageData.data[idx] = value;
            imageData.data[idx + 1] = value;
            imageData.data[idx + 2] = value;
            imageData.data[idx + 3] = 255;
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return imageData;
}

async function canvasToPngBlob(imageData: ImageData): Promise<Blob> {
    const canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob'));
            }
        }, 'image/png');
    });
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function downloadAsFile(filename: string, content: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    downloadBlob(filename, blob);
}

function downloadBlob(filename: string, blob: Blob): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
