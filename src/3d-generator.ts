import { PartListImage } from "./image-utils";
import { saveAs } from "file-saver";

export type ThreeDFormat = "3mf" | "openscad-masks";

export interface ThreeDSettings {
    format: ThreeDFormat;
    pixelHeight: number;
    pixelWidth: number;
    baseHeight: number;
}

export async function generate3D(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    if (settings.format === "3mf") {
        await generate3MF(image, settings);
    } else {
        await generateOpenSCADMasks(image, settings);
    }
}

async function generate3MF(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const triangles: string[] = [];
    let objectId = 1;
    const objects: string[] = [];
    
    // Generate a mesh for each color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx].target;
        const vertices: Array<[number, number, number]> = [];
        const faces: Array<[number, number, number]> = [];
        
        // Build mesh for this color
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    addPixelCube(x, y, vertices, faces, settings);
                }
            }
        }
        
        if (vertices.length === 0) continue;
        
        // Convert to 3MF mesh format
        let meshXML = '    <mesh>\n';
        meshXML += '      <vertices>\n';
        for (const [vx, vy, vz] of vertices) {
            meshXML += `        <vertex x="${vx}" y="${vy}" z="${vz}"/>\n`;
        }
        meshXML += '      </vertices>\n';
        meshXML += '      <triangles>\n';
        for (const [v1, v2, v3] of faces) {
            meshXML += `        <triangle v1="${v1}" v2="${v2}" v3="${v3}"/>\n`;
        }
        meshXML += '      </triangles>\n';
        meshXML += '    </mesh>\n';
        
        const colorHex = rgbToHex(color.r, color.g, color.b);
        objects.push(`  <object id="${objectId}" type="model" name="${color.name}">
${meshXML}
  </object>`);
        
        triangles.push(`    <item objectid="${objectId}" transform="1 0 0 0 1 0 0 0 1 0 0 0"/>`);
        objectId++;
    }
    
    const modelXML = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">
  <resources>
${objects.join('\n')}
    <object id="${objectId}" type="model">
      <components>
${triangles.join('\n')}
      </components>
    </object>
  </resources>
  <build>
    <item objectid="${objectId}"/>
  </build>
</model>`;
    
    // Create 3MF package (which is a ZIP file)
    const zip = await createZip();
    await zip.addFile("3D/3dmodel.model", modelXML);
    await zip.addFile("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>`);
    await zip.addFile("_rels/.rels", `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Id="rel0"/>
</Relationships>`);
    
    const blob = await zip.generate();
    saveAs(blob, "firaga-3d.3mf");
}

async function generateOpenSCADMasks(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const zip = await createZip();
    const scadCommands: string[] = [];
    
    scadCommands.push(`// Generated by firaga.io`);
    scadCommands.push(`// Image size: ${image.width}x${image.height}`);
    scadCommands.push(`pixel_width = ${settings.pixelWidth};`);
    scadCommands.push(`pixel_height = ${settings.pixelHeight};`);
    scadCommands.push(`base_height = ${settings.baseHeight};`);
    scadCommands.push(``);
    
    // Generate one mask image per color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx].target;
        const filename = `mask_${colorIdx}_${sanitizeFilename(color.name)}.png`;
        
        // Create black and white mask
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = image.width;
        maskCanvas.height = image.height;
        const ctx = maskCanvas.getContext("2d");
        if (!ctx) continue;
        
        const imageData = ctx.createImageData(image.width, image.height);
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                const idx = (y * image.width + x) * 4;
                const isThisColor = image.pixels[y][x] === colorIdx;
                const value = isThisColor ? 255 : 0;
                imageData.data[idx] = value;     // R
                imageData.data[idx + 1] = value; // G
                imageData.data[idx + 2] = value; // B
                imageData.data[idx + 3] = 255;   // A
            }
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Convert canvas to blob
        const blob = await new Promise<Blob | null>((resolve) => {
            maskCanvas.toBlob(resolve, "image/png");
        });
        if (!blob) continue;
        
        await zip.addFileBlob(filename, blob);
        
        // Add SCAD command for this layer
        const colorRGB = `[${color.r / 255}, ${color.g / 255}, ${color.b / 255}]`;
        scadCommands.push(`// ${color.name}`);
        scadCommands.push(`color(${colorRGB})`);
        scadCommands.push(`  translate([0, 0, ${colorIdx} * pixel_height])`);
        scadCommands.push(`    scale([pixel_width, pixel_width, pixel_height])`);
        scadCommands.push(`      surface(file = "${filename}", center = true, invert = true);`);
        scadCommands.push(``);
    }
    
    const scadContent = scadCommands.join('\n');
    await zip.addFile("model.scad", scadContent);
    
    const blob = await zip.generate();
    saveAs(blob, "firaga-openscad.zip");
}

function addPixelCube(
    x: number,
    y: number,
    vertices: Array<[number, number, number]>,
    faces: Array<[number, number, number]>,
    settings: ThreeDSettings
): void {
    const pw = settings.pixelWidth;
    const ph = settings.pixelHeight;
    const x0 = x * pw;
    const x1 = (x + 1) * pw;
    const y0 = y * pw;
    const y1 = (y + 1) * pw;
    const z0 = 0;
    const z1 = ph;
    
    const baseIdx = vertices.length;
    
    // 8 vertices of a cube
    vertices.push([x0, y0, z0]); // 0
    vertices.push([x1, y0, z0]); // 1
    vertices.push([x1, y1, z0]); // 2
    vertices.push([x0, y1, z0]); // 3
    vertices.push([x0, y0, z1]); // 4
    vertices.push([x1, y0, z1]); // 5
    vertices.push([x1, y1, z1]); // 6
    vertices.push([x0, y1, z1]); // 7
    
    // 12 triangles (2 per face, 6 faces)
    // Bottom face (z=0)
    faces.push([baseIdx + 0, baseIdx + 2, baseIdx + 1]);
    faces.push([baseIdx + 0, baseIdx + 3, baseIdx + 2]);
    
    // Top face (z=z1)
    faces.push([baseIdx + 4, baseIdx + 5, baseIdx + 6]);
    faces.push([baseIdx + 4, baseIdx + 6, baseIdx + 7]);
    
    // Front face (y=y0)
    faces.push([baseIdx + 0, baseIdx + 1, baseIdx + 5]);
    faces.push([baseIdx + 0, baseIdx + 5, baseIdx + 4]);
    
    // Back face (y=y1)
    faces.push([baseIdx + 3, baseIdx + 7, baseIdx + 6]);
    faces.push([baseIdx + 3, baseIdx + 6, baseIdx + 2]);
    
    // Left face (x=x0)
    faces.push([baseIdx + 0, baseIdx + 4, baseIdx + 7]);
    faces.push([baseIdx + 0, baseIdx + 7, baseIdx + 3]);
    
    // Right face (x=x1)
    faces.push([baseIdx + 1, baseIdx + 2, baseIdx + 6]);
    faces.push([baseIdx + 1, baseIdx + 6, baseIdx + 5]);
}

function rgbToHex(r: number, g: number, b: number): string {
    return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

// Simple ZIP file creator using browser APIs
interface SimpleZip {
    addFile(path: string, content: string): Promise<void>;
    addFileBlob(path: string, blob: Blob): Promise<void>;
    generate(): Promise<Blob>;
}

async function createZip(): Promise<SimpleZip> {
    // Use fflate library if available, otherwise fall back to simple implementation
    if (typeof window !== 'undefined' && (window as any).fflate) {
        return createFflateZip();
    }
    
    // Fallback: load fflate from CDN
    await loadFflate();
    return createFflateZip();
}

async function loadFflate(): Promise<void> {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/fflate@0.8.2/umd/index.js';
        script.onload = () => resolve();
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

function createFflateZip(): SimpleZip {
    const files: Record<string, Uint8Array> = {};
    const fflate = (window as any).fflate;
    
    return {
        async addFile(path: string, content: string): Promise<void> {
            const encoder = new TextEncoder();
            files[path] = encoder.encode(content);
        },
        
        async addFileBlob(path: string, blob: Blob): Promise<void> {
            const arrayBuffer = await blob.arrayBuffer();
            files[path] = new Uint8Array(arrayBuffer);
        },
        
        async generate(): Promise<Blob> {
            return new Promise((resolve, reject) => {
                fflate.zip(files, (err: Error | null, data: Uint8Array) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(new Blob([data], { type: 'application/zip' }));
                    }
                });
            });
        }
    };
}
