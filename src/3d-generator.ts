import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export interface ThreeDSettings {
    format: "3mf" | "openscad";
    filename: string;
    pixelHeight: number;
    baseHeight: number;
}

export async function generate3D(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    if (settings.format === "3mf") {
        await generate3MF(image, settings);
    } else {
        await generateOpenSCAD(image, settings);
    }
}

async function generate3MF(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const pixelSize = 1.0;
    const baseZ = settings.baseHeight;
    const pixelZ = settings.pixelHeight;

    let meshXml = '';
    let objectId = 1;
    const resources: string[] = [];

    // Create a mesh for each color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx];
        const vertices: Array<[number, number, number]> = [];
        const triangles: Array<[number, number, number]> = [];

        // Collect all pixels of this color
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    addCube(x, y, vertices, triangles);
                }
            }
        }

        if (vertices.length === 0) continue;

        // Build mesh XML
        let meshContent = '<mesh>\n<vertices>\n';
        for (const [vx, vy, vz] of vertices) {
            meshContent += `<vertex x="${vx}" y="${vy}" z="${vz}" />\n`;
        }
        meshContent += '</vertices>\n<triangles>\n';
        for (const [v1, v2, v3] of triangles) {
            meshContent += `<triangle v1="${v1}" v2="${v2}" v3="${v3}" />\n`;
        }
        meshContent += '</triangles>\n</mesh>';

        const hexColor = colorEntryToHex(color.target).substring(1);
        resources.push(`<object id="${objectId}" type="model">
${meshContent}
</object>`);
        resources.push(`<basematerials id="${objectId + 1000}">
<base name="${color.target.name}" displaycolor="#${hexColor}" />
</basematerials>`);

        objectId++;
    }

    const xml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">
<resources>
${resources.join('\n')}
</resources>
<build>
${Array.from({ length: objectId - 1 }, (_, i) => `<item objectid="${i + 1}" />`).join('\n')}
</build>
</model>`;

    downloadFile(settings.filename + '.3mf', xml, 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml');

    function addCube(x: number, y: number, verts: Array<[number, number, number]>, tris: Array<[number, number, number]>): void {
        const x0 = x * pixelSize;
        const x1 = (x + 1) * pixelSize;
        const y0 = y * pixelSize;
        const y1 = (y + 1) * pixelSize;
        const z0 = baseZ;
        const z1 = baseZ + pixelZ;

        const baseIdx = verts.length;

        // 8 vertices of a cube
        verts.push([x0, y0, z0], [x1, y0, z0], [x1, y1, z0], [x0, y1, z0]);
        verts.push([x0, y0, z1], [x1, y0, z1], [x1, y1, z1], [x0, y1, z1]);

        // 12 triangles (2 per face, 6 faces)
        const faces: Array<[number, number, number, number]> = [
            [0, 1, 2, 3], // bottom
            [4, 7, 6, 5], // top
            [0, 4, 5, 1], // front
            [1, 5, 6, 2], // right
            [2, 6, 7, 3], // back
            [3, 7, 4, 0]  // left
        ];

        for (const [a, b, c, d] of faces) {
            tris.push([baseIdx + a, baseIdx + b, baseIdx + c]);
            tris.push([baseIdx + a, baseIdx + c, baseIdx + d]);
        }
    }
}

async function generateOpenSCAD(image: PartListImage, settings: ThreeDSettings): Promise<void> {
    const JSZip = await loadJSZip();
    const zip = new JSZip();

    const pixelHeight = settings.pixelHeight;
    const baseHeight = settings.baseHeight;

    // Generate one image per color
    const scadLines: string[] = [];
    scadLines.push(`// Generated by firaga.io`);
    scadLines.push(`pixel_size = 1;`);
    scadLines.push(`pixel_height = ${pixelHeight};`);
    scadLines.push(`base_height = ${baseHeight};`);
    scadLines.push(``);

    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx];
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;

        // Fill with white (background)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw black pixels for this color
        ctx.fillStyle = '#000000';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        // Convert to PNG and add to zip
        const dataUrl = canvas.toDataURL('image/png');
        const base64Data = dataUrl.split(',')[1];
        const filename = `color_${colorIdx}_${sanitizeFilename(color.target.name)}.png`;
        zip.file(filename, base64Data, { base64: true });

        // Add to OpenSCAD file
        const hexColor = colorEntryToHex(color.target).substring(1);
        const r = parseInt(hexColor.substring(0, 2), 16) / 255;
        const g = parseInt(hexColor.substring(2, 4), 16) / 255;
        const b = parseInt(hexColor.substring(4, 6), 16) / 255;

        scadLines.push(`// ${color.target.name}`);
        scadLines.push(`color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])`);
        scadLines.push(`  surface(file = "${filename}", center = true, invert = true);`);
        scadLines.push(``);
    }

    const scadContent = scadLines.join('\n');
    zip.file('model.scad', scadContent);

    const blob = await zip.generateAsync({ type: 'blob' });
    downloadBlob(settings.filename + '_openscad.zip', blob);
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function downloadFile(filename: string, content: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    downloadBlob(filename, blob);
}

function downloadBlob(filename: string, blob: Blob): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

async function loadJSZip(): Promise<any> {
    if (!(window as any).JSZip) {
        await new Promise<void>((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load JSZip'));
            document.head.appendChild(script);
        });
    }
    return (window as any).JSZip;
}
