import { saveAs } from 'file-saver';
import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

/**
 * Generates a zip file with:
 * - One monochrome (black/white) PNG per color
 * - An OpenSCAD file that loads all images and combines them into a 3D display
 */
export async function generateOpenSCADMasks(image: PartListImage, filename: string): Promise<void> {
    const files: Record<string, Blob | string> = {};
    
    // Generate one monochrome image per color
    const imagePromises: Array<Promise<void>> = [];
    for (let partIdx = 0; partIdx < image.partList.length; partIdx++) {
        const part = image.partList[partIdx];
        const colorName = sanitizeFilename(part.target.name);
        const imageName = `color_${partIdx}_${colorName}.png`;
        
        imagePromises.push(
            generateMonochromeImage(image, partIdx).then(blob => {
                files[imageName] = blob;
            })
        );
    }
    
    await Promise.all(imagePromises);
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image);
    files[`${filename}.scad`] = scadContent;
    
    // Also create a README
    const readmeContent = generateReadme(image);
    files['README.txt'] = readmeContent;
    
    // Create zip file
    const zip = await createZipFile(files);
    saveAs(zip, `${filename}_openscad.zip`);
}

async function generateMonochromeImage(image: PartListImage, partIdx: number): Promise<Blob> {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const pixelColorIdx = image.pixels[y][x];
            
            // White (255) where this color exists, black (0) elsewhere
            const value = pixelColorIdx === partIdx ? 255 : 0;
            imageData.data[idx] = value;
            imageData.data[idx + 1] = value;
            imageData.data[idx + 2] = value;
            imageData.data[idx + 3] = 255; // Full opacity
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob from canvas'));
            }
        }, 'image/png');
    });
}

function generateOpenSCADFile(image: PartListImage): string {
    const voxelSize = 1; // 1mm per pixel
    const baseHeight = 0.5; // Base layer height
    const colorHeight = 2; // Height per color layer
    
    let scadCode = `// Generated by firaga.io
// 3D pixel art using surface heightmap
// Each color is represented as a separate layer

$fn = 4; // Low polygon count for faster rendering, increase for smoother output

`;
    
    // Add a base plate
    scadCode += `// Base plate
translate([0, 0, -${baseHeight}])
  cube([${image.width * voxelSize}, ${image.height * voxelSize}, ${baseHeight}]);

`;
    
    // Add each color as a surface
    for (let partIdx = 0; partIdx < image.partList.length; partIdx++) {
        const part = image.partList[partIdx];
        const colorName = sanitizeFilename(part.target.name);
        const imageName = `color_${partIdx}_${colorName}.png`;
        const hexColor = colorEntryToHex(part.target);
        const rgb = hexToRgbNormalized(hexColor);
        
        scadCode += `// Color: ${part.target.name}
color([${rgb[0]}, ${rgb[1]}, ${rgb[2]}])
  translate([0, 0, ${partIdx * 0.01}]) // Slight z-offset to prevent z-fighting
    surface(file = "${imageName}", center = false, convexity = 10);

`;
    }
    
    scadCode += `// Alternative: Use linear_extrude for solid blocks
// Uncomment the following and comment out the surface() calls above

`;
    
    for (let partIdx = 0; partIdx < image.partList.length; partIdx++) {
        const part = image.partList[partIdx];
        const colorName = sanitizeFilename(part.target.name);
        const imageName = `color_${partIdx}_${colorName}.png`;
        const hexColor = colorEntryToHex(part.target);
        const rgb = hexToRgbNormalized(hexColor);
        
        scadCode += `/*
color([${rgb[0]}, ${rgb[1]}, ${rgb[2]}])
  translate([0, 0, ${partIdx * colorHeight}])
    linear_extrude(height = ${colorHeight})
      projection()
        surface(file = "${imageName}", center = false);
*/

`;
    }
    
    return scadCode;
}

function generateReadme(image: PartListImage): string {
    let readme = `Firaga.io OpenSCAD Export
==========================

This archive contains:
1. One PNG image per color (${image.partList.length} colors total)
2. An OpenSCAD (.scad) file that combines them into a 3D model

How to use:
-----------
1. Install OpenSCAD from https://openscad.org/
2. Extract all files to the same directory
3. Open the .scad file in OpenSCAD
4. Press F5 to preview or F6 to render
5. Export to STL or other 3D format using File > Export

Notes:
------
- The surface() function creates a heightmap from the grayscale images
- Each pixel in the image becomes a point in 3D space
- White pixels (255) are raised, black pixels (0) stay at base level
- You can modify the .scad file to adjust sizes, heights, and rendering options
- For better results with 3D printing, consider using the "linear_extrude" 
  approach commented in the .scad file

Colors in this export:
`;
    
    for (let i = 0; i < image.partList.length; i++) {
        const part = image.partList[i];
        const colorName = sanitizeFilename(part.target.name);
        const imageName = `color_${i}_${colorName}.png`;
        readme += `- ${part.target.name} (${part.count} pixels) -> ${imageName}\n`;
    }
    
    return readme;
}

async function createZipFile(files: Record<string, Blob | string>): Promise<Blob> {
    const encoder = new TextEncoder();
    const chunks: Uint8Array[] = [];
    const centralDirectory: Uint8Array[] = [];
    let offset = 0;
    
    for (const [path, content] of Object.entries(files)) {
        let data: Uint8Array;
        
        if (typeof content === 'string') {
            data = encoder.encode(content);
        } else {
            data = new Uint8Array(await content.arrayBuffer());
        }
        
        const pathBytes = encoder.encode(path);
        
        // Local file header
        const header = new Uint8Array(30 + pathBytes.length);
        const view = new DataView(header.buffer);
        view.setUint32(0, 0x04034b50, true); // Local file header signature
        view.setUint16(4, 20, true); // Version needed to extract
        view.setUint16(6, 0, true); // General purpose bit flag
        view.setUint16(8, 0, true); // Compression method (0 = no compression)
        view.setUint16(10, 0, true); // Last mod file time
        view.setUint16(12, 0, true); // Last mod file date
        view.setUint32(14, crc32(data), true); // CRC-32
        view.setUint32(18, data.length, true); // Compressed size
        view.setUint32(22, data.length, true); // Uncompressed size
        view.setUint16(26, pathBytes.length, true); // File name length
        view.setUint16(28, 0, true); // Extra field length
        header.set(pathBytes, 30);
        
        chunks.push(header);
        chunks.push(data);
        
        // Central directory header
        const cdHeader = new Uint8Array(46 + pathBytes.length);
        const cdView = new DataView(cdHeader.buffer);
        cdView.setUint32(0, 0x02014b50, true); // Central directory signature
        cdView.setUint16(4, 20, true); // Version made by
        cdView.setUint16(6, 20, true); // Version needed to extract
        cdView.setUint16(8, 0, true); // General purpose bit flag
        cdView.setUint16(10, 0, true); // Compression method
        cdView.setUint16(12, 0, true); // Last mod file time
        cdView.setUint16(14, 0, true); // Last mod file date
        cdView.setUint32(16, crc32(data), true); // CRC-32
        cdView.setUint32(20, data.length, true); // Compressed size
        cdView.setUint32(24, data.length, true); // Uncompressed size
        cdView.setUint16(28, pathBytes.length, true); // File name length
        cdView.setUint16(30, 0, true); // Extra field length
        cdView.setUint16(32, 0, true); // File comment length
        cdView.setUint16(34, 0, true); // Disk number start
        cdView.setUint16(36, 0, true); // Internal file attributes
        cdView.setUint32(38, 0, true); // External file attributes
        cdView.setUint32(42, offset, true); // Relative offset of local header
        cdHeader.set(pathBytes, 46);
        
        centralDirectory.push(cdHeader);
        offset += header.length + data.length;
    }
    
    const cdData = new Uint8Array(centralDirectory.reduce((sum, cd) => sum + cd.length, 0));
    let cdOffset = 0;
    for (const cd of centralDirectory) {
        cdData.set(cd, cdOffset);
        cdOffset += cd.length;
    }
    
    // End of central directory record
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 0x06054b50, true); // End of central directory signature
    eocdView.setUint16(4, 0, true); // Number of this disk
    eocdView.setUint16(6, 0, true); // Disk where central directory starts
    eocdView.setUint16(8, centralDirectory.length, true); // Number of central directory records on this disk
    eocdView.setUint16(10, centralDirectory.length, true); // Total number of central directory records
    eocdView.setUint32(12, cdData.length, true); // Size of central directory
    eocdView.setUint32(16, offset, true); // Offset of start of central directory
    eocdView.setUint16(20, 0, true); // Comment length
    
    const allChunks = [...chunks, cdData, eocd];
    const totalLength = allChunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of allChunks) {
        result.set(chunk, position);
        position += chunk.length;
    }
    
    return new Blob([result], { type: 'application/zip' });
}

function crc32(data: Uint8Array): number {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i++) {
        crc ^= data[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc >>> 1) ^ ((crc & 1) ? 0xedb88320 : 0);
        }
    }
    return (crc ^ 0xffffffff) >>> 0;
}

function hexToRgbNormalized(hex: string): [number, number, number] {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) return [1, 1, 1];
    return [
        parseInt(result[1], 16) / 255,
        parseInt(result[2], 16) / 255,
        parseInt(result[3], 16) / 255
    ];
}

function sanitizeFilename(name: string): string {
    return name
        .replace(/[^a-z0-9]/gi, '_')
        .replace(/_+/g, '_')
        .toLowerCase();
}
