import { saveAs } from 'file-saver';
import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

declare const JSZip: any;

export function generateOpenSCAD(image: PartListImage, filename: string) {
    loadJSZipAnd(() => generateOpenSCADWorker(image, filename));
}

async function loadJSZipAnd(func: () => void) {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        const tag = document.createElement("script");
        tag.id = tagName;
        tag.onload = () => {
            func();
        };
        tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        document.head.appendChild(tag);
    } else {
        func();
    }
}

function generateOpenSCADWorker(image: PartListImage, filename: string) {
    const zip = new JSZip();
    
    const heightPerLayer = 1; // Height of each pixel layer
    const pixelSize = 5; // Size of each pixel in mm
    
    // Generate one monochrome image per color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx];
        if (!color) continue;
        
        // Create a canvas for this color's mask
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, image.width, image.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = 'black';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to PNG blob and add to zip
        canvas.toBlob((blob) => {
            if (blob) {
                const colorName = sanitizeFilename(color.target.name);
                zip.file(`mask_${colorIdx}_${colorName}.png`, blob);
            }
        });
    }
    
    // Generate OpenSCAD file
    const scadContent = generateSCADContent(image, pixelSize, heightPerLayer);
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate the zip file after a short delay to ensure all blobs are added
    setTimeout(() => {
        zip.generateAsync({ type: 'blob' }).then((blob: Blob) => {
            saveAs(blob, `${filename}_openscad.zip`);
        });
    }, 100);
}

function generateSCADContent(image: PartListImage, pixelSize: number, heightPerLayer: number): string {
    const colorLayers: string[] = [];
    
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx];
        if (!color) continue;
        
        const colorName = sanitizeFilename(color.target.name);
        const hexColor = colorEntryToHex(color.target);
        const rgb = hexToRGB(hexColor);
        const z = colorIdx * heightPerLayer;
        
        colorLayers.push(`
// Layer for ${color.target.name}
color(${rgb})
translate([0, 0, ${z}])
scale([${pixelSize}, ${pixelSize}, ${heightPerLayer}])
surface(file = "mask_${colorIdx}_${colorName}.png", center = false, invert = true);
`);
    }
    
    return `// Generated by firaga.io
// Image dimensions: ${image.width} x ${image.height}
// Pixel size: ${pixelSize}mm
// Layer height: ${heightPerLayer}mm

// Render all color layers
union() {
${colorLayers.join('\n')}
}
`;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function hexToRGB(hex: string): string {
    // Remove # if present
    hex = hex.replace('#', '');
    
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;
    
    return `[${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}]`;
}
