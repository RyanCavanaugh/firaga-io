import { PartListImage } from "./image-utils";

declare const saveAs: (blob: Blob, filename: string) => void;
declare const JSZip: {
    new(): JSZipInstance;
};

interface JSZipInstance {
    file(name: string, data: string | Uint8Array): void;
    generateAsync(options: { type: string }): Promise<Blob>;
}

/**
 * Generate a ZIP file containing OpenSCAD masks:
 * - One monochrome (black/white) PNG per color
 * - An OpenSCAD (.scad) file that loads and combines all masks
 */
export function generateOpenSCADMasks(image: PartListImage, filename: string): void {
    loadDependenciesAnd(async () => {
        const zip = new JSZip();
        
        // Generate mask images for each color
        const maskFiles: string[] = [];
        for (let i = 0; i < image.partList.length; i++) {
            const part = image.partList[i];
            const maskFilename = `mask_${i}_${sanitizeFilename(part.target.name)}.png`;
            const maskData = createMaskImage(image, i);
            zip.file(maskFilename, maskData);
            maskFiles.push(maskFilename);
        }
        
        // Generate OpenSCAD file
        const scadContent = createOpenSCADFile(image, maskFiles);
        zip.file(`${filename}.scad`, scadContent);
        
        // Generate the ZIP file
        const blob = await zip.generateAsync({ type: "blob" });
        saveAs(blob, `${filename}_openscad.zip`);
    });
}

function createMaskImage(image: PartListImage, colorIndex: number): Uint8Array {
    const canvas = document.createElement("canvas");
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext("2d");
    
    if (!ctx) {
        throw new Error("Failed to get canvas context");
    }
    
    const imageData = ctx.createImageData(image.width, image.height);
    const data = imageData.data;
    
    // Create black and white mask
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const pixelColorIndex = image.pixels[y][x];
            
            // White (255) where this color is present, black (0) otherwise
            const value = pixelColorIndex === colorIndex ? 255 : 0;
            data[idx] = value;     // R
            data[idx + 1] = value; // G
            data[idx + 2] = value; // B
            data[idx + 3] = 255;   // A (fully opaque)
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Convert canvas to PNG data
    const dataUrl = canvas.toDataURL("image/png");
    const base64 = dataUrl.split(",")[1];
    const binary = atob(base64);
    const array = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        array[i] = binary.charCodeAt(i);
    }
    
    return array;
}

function createOpenSCADFile(image: PartListImage, maskFiles: string[]): string {
    const pixelSize = 1.0;  // Size of each pixel in mm
    const heightPerColor = 0.5; // Height of each color layer in mm
    
    const lines: string[] = [
        "// OpenSCAD file for 3D pixel art",
        "// Generated by firaga.io",
        "",
        "// Parameters - adjust these to customize your model",
        `pixel_size = ${pixelSize}; // Size of each pixel in mm`,
        `height_per_layer = ${heightPerColor}; // Height of each color layer in mm`,
        `image_width = ${image.width};`,
        `image_height = ${image.height};`,
        "",
        "// Color definitions (RGB values normalized to 0-1)",
    ];
    
    // Add color definitions
    image.partList.forEach((part, idx) => {
        const r = (part.target.r / 255).toFixed(3);
        const g = (part.target.g / 255).toFixed(3);
        const b = (part.target.b / 255).toFixed(3);
        lines.push(`color_${idx} = [${r}, ${g}, ${b}]; // ${part.target.name}`);
    });
    
    lines.push("");
    lines.push("// Main model - union of all color layers");
    lines.push("union() {");
    
    // Add each color layer
    maskFiles.forEach((maskFile, idx) => {
        const part = image.partList[idx];
        lines.push(`  // Layer ${idx}: ${part.target.name}`);
        lines.push(`  color(color_${idx})`);
        lines.push(`    translate([0, 0, ${idx} * height_per_layer])`);
        lines.push(`      surface(file = "${maskFile}", invert = true, center = true);`);
        lines.push("");
    });
    
    lines.push("}");
    lines.push("");
    lines.push("// Alternative: Individual color modules for manual composition");
    lines.push("// Uncomment the module you want to view individually");
    
    maskFiles.forEach((maskFile, idx) => {
        const part = image.partList[idx];
        lines.push("");
        lines.push(`module layer_${idx}() { // ${part.target.name}`);
        lines.push(`  color(color_${idx})`);
        lines.push(`    surface(file = "${maskFile}", invert = true, center = true);`);
        lines.push(`}`);
        lines.push(`// layer_${idx}();`);
    });
    
    return lines.join("\n");
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, "_");
}

async function loadDependenciesAnd(func: () => Promise<void>): Promise<void> {
    const fileSaverTag = "file-saver-script-tag";
    const jsZipTag = "jszip-script-tag";
    
    let fileSaverLoaded = false;
    let jsZipLoaded = false;
    
    const checkAndRun = () => {
        if (fileSaverLoaded && jsZipLoaded) {
            func();
        }
    };
    
    // Load FileSaver.js
    const fileSaverEl = document.getElementById(fileSaverTag);
    if (fileSaverEl === null) {
        const tag = document.createElement("script");
        tag.id = fileSaverTag;
        tag.onload = () => {
            fileSaverLoaded = true;
            checkAndRun();
        };
        tag.src = "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js";
        document.head.appendChild(tag);
    } else {
        fileSaverLoaded = true;
    }
    
    // Load JSZip
    const jsZipEl = document.getElementById(jsZipTag);
    if (jsZipEl === null) {
        const tag = document.createElement("script");
        tag.id = jsZipTag;
        tag.onload = () => {
            jsZipLoaded = true;
            checkAndRun();
        };
        tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        document.head.appendChild(tag);
    } else {
        jsZipLoaded = true;
    }
    
    checkAndRun();
}
