import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";
import { saveAs } from "file-saver";

declare const JSZip: any;

export interface ThreeDSettings {
    format: "3mf" | "openscad";
    thickness: number;
    carveSize: readonly [number, number];
    pitch: number;
    filename: string;
}

export async function generateOpenSCADMasks(image: PartListImage, settings: ThreeDSettings) {
    // Load JSZip if not already loaded
    await loadJSZip();

    const zip = new JSZip();
    const { pitch, thickness } = settings;

    // Generate one black/white mask image per color
    const imagePromises = image.partList.map((part, colorIdx) => {
        return generateMaskImage(image, colorIdx).then(blob => {
            const filename = `mask_${colorIdx}_${sanitizeFilename(part.target.name)}.png`;
            zip.file(filename, blob);
            return { filename, color: part.target.name, hex: colorEntryToHex(part.target) };
        });
    });

    const maskFiles = await Promise.all(imagePromises);

    // Generate OpenSCAD file
    let scadContent = `// Generated by firaga.io
// Pixel art 3D render with heightmap

// Parameters
pixel_size = ${pitch}; // mm per pixel
thickness = ${thickness}; // mm thickness
image_width = ${image.width};
image_height = ${image.height};

// Import and extrude each color mask
`;

    maskFiles.forEach((mask, idx) => {
        const hexColor = mask.hex.substring(1); // Remove #
        const r = parseInt(hexColor.substring(0, 2), 16) / 255;
        const g = parseInt(hexColor.substring(2, 4), 16) / 255;
        const b = parseInt(hexColor.substring(4, 6), 16) / 255;
        
        scadContent += `
// ${mask.color}
color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
translate([0, 0, ${idx * 0.01}]) // Slight z-offset to prevent z-fighting
linear_extrude(height = thickness)
scale([pixel_size, pixel_size, 1])
surface(file = "${mask.filename}", center = false, invert = true);
`;
    });

    zip.file(`${settings.filename}.scad`, scadContent);

    // Generate README
    const readmeContent = `Firaga.io OpenSCAD Export
==========================

This archive contains:
- One monochrome PNG mask per color
- An OpenSCAD file (.scad) that combines all masks into a 3D model

To use:
1. Extract all files to the same directory
2. Open the .scad file in OpenSCAD
3. Render and export as STL or other 3D format

Each mask represents pixels of one color, with white pixels indicating
where that color should appear in the final 3D model.
`;

    zip.file("README.txt", readmeContent);

    // Generate and download the zip file
    const zipBlob = await zip.generateAsync({ type: "blob" });
    saveAs(zipBlob, `${settings.filename}_openscad.zip`);
}

function generateMaskImage(image: PartListImage, colorIdx: number): Promise<Blob> {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;

        // Fill with black background
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw white pixels where this color appears
        ctx.fillStyle = 'white';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        canvas.toBlob((blob) => {
            resolve(blob!);
        }, 'image/png');
    });
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

async function loadJSZip() {
    return new Promise<void>((resolve) => {
        const tagName = "jszip-script-tag";
        const scriptEl = document.getElementById(tagName);
        if (scriptEl === null) {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        } else {
            resolve();
        }
    });
}
