import { PartListImage } from "./image-utils";
// Using fflate for zip generation (smaller and browser-friendly)
declare const fflate: {
  zipSync(files: Record<string, Uint8Array>): Uint8Array;
};

export type OpenSCADSettings = {
  pixelSize: number;
  heightPerLayer: number;
  filename: string;
};

export async function generateOpenSCADMasks(
  image: PartListImage,
  settings: OpenSCADSettings
): Promise<void> {
  await loadFflateLibrary();
  
  const files: Record<string, Uint8Array> = {};
  const { width, height, partList, pixels } = image;
  const { pixelSize, heightPerLayer } = settings;

  // Generate one mask image per color
  const imagePromises = partList.map(async (part, partIndex) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    
    if (!ctx) {
      throw new Error("Failed to get canvas context");
    }

    const imageData = ctx.createImageData(width, height);
    
    // Create black and white mask
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const isThisColor = pixels[y][x] === partIndex;
        const value = isThisColor ? 255 : 0;
        
        imageData.data[idx] = value;     // R
        imageData.data[idx + 1] = value; // G
        imageData.data[idx + 2] = value; // B
        imageData.data[idx + 3] = 255;   // A
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    const blob = await new Promise<Blob>((resolve, reject) => {
      canvas.toBlob((b) => {
        if (b) {
          resolve(b);
        } else {
          reject(new Error("Failed to create blob"));
        }
      }, "image/png");
    });
    
    const sanitizedName = sanitizeFilename(part.target.name);
    const arrayBuffer = await blob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    
    files[`mask_${partIndex}_${sanitizedName}.png`] = uint8Array;
    
    return { partIndex, name: sanitizedName, symbol: part.symbol };
  });

  const maskInfo = await Promise.all(imagePromises);

  // Generate OpenSCAD file
  const scadContent = generateOpenSCADFile(maskInfo, width, height, pixelSize, heightPerLayer);
  const encoder = new TextEncoder();
  files["display.scad"] = encoder.encode(scadContent);
  
  // Generate the zip and download
  const zipped = fflate.zipSync(files);
  const zipBlob = new Blob([zipped], { type: "application/zip" });
  downloadBlob(zipBlob, `${settings.filename}_openscad.zip`);
}

function generateOpenSCADFile(
  masks: Array<{ partIndex: number; name: string; symbol: string }>,
  width: number,
  height: number,
  pixelSize: number,
  heightPerLayer: number
): string {
  const layers = masks.map((mask, index) => {
    const zOffset = index * heightPerLayer;
    return `  // Layer ${index}: ${mask.name} (${mask.symbol})
  translate([0, 0, ${zOffset}])
    surface(file = "mask_${mask.partIndex}_${mask.name}.png", 
            center = true, 
            convexity = 5);`;
  }).join("\n\n");

  return `// Generated by firaga.io
// 3D display of pixel art image

// Image dimensions
image_width = ${width};
image_height = ${height};

// Physical dimensions (mm)
pixel_size = ${pixelSize};
height_per_layer = ${heightPerLayer};

// Scale factor for heightmap (white pixels = full height)
scale_x = pixel_size;
scale_y = pixel_size;
scale_z = height_per_layer;

union() {
${layers}
}

// To render:
// 1. Open this file in OpenSCAD
// 2. Press F5 to preview or F6 to render
// 3. Export as STL for 3D printing
`;
}

function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_-]/g, "_")
    .replace(/_+/g, "_")
    .substring(0, 50);
}

async function loadFflateLibrary(): Promise<void> {
  const tagName = "fflate-script-tag";
  const scriptEl = document.getElementById(tagName);
  if (scriptEl === null) {
    return new Promise((resolve, reject) => {
      const tag = document.createElement("script");
      tag.id = tagName;
      tag.onload = () => resolve();
      tag.onerror = () => reject(new Error("Failed to load fflate library"));
      tag.src = "https://cdn.jsdelivr.net/npm/fflate@0.8.1/umd/index.js";
      document.head.appendChild(tag);
    });
  }
}

function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
