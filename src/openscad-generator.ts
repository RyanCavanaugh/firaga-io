import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export interface OpenSCADMasksSettings {
    pixelHeight: number;
    pixelWidth: number;
    filename: string;
}

export function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADMasksSettings): void {
    const { pixelHeight, pixelWidth, filename } = settings;
    
    // Create canvas for generating mask images
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }
    
    const maskImages: Record<string, string> = {};
    const colorNames: string[] = [];
    
    // Generate a black/white mask image for each color
    image.partList.forEach((part, colorIndex) => {
        const imgData = ctx.createImageData(image.width, image.height);
        
        // Fill with white background
        for (let i = 0; i < imgData.data.length; i += 4) {
            imgData.data[i] = 255;     // R
            imgData.data[i + 1] = 255; // G
            imgData.data[i + 2] = 255; // B
            imgData.data[i + 3] = 255; // A
        }
        
        // Mark pixels of this color as black
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIndex) {
                    const idx = (y * image.width + x) * 4;
                    imgData.data[idx] = 0;     // R
                    imgData.data[idx + 1] = 0; // G
                    imgData.data[idx + 2] = 0; // B
                }
            }
        }
        
        ctx.putImageData(imgData, 0, 0);
        const dataUrl = canvas.toDataURL('image/png');
        
        // Extract base64 data
        const base64Data = dataUrl.split(',')[1];
        const colorName = sanitizeFilename(part.target.name);
        colorNames.push(colorName);
        maskImages[`mask_${colorName}.png`] = base64Data;
    });
    
    // Generate OpenSCAD file
    const scadLines: string[] = [];
    scadLines.push(`// Generated by firaga.io`);
    scadLines.push(`// Pixel dimensions: ${image.width} x ${image.height}`);
    scadLines.push(`pixel_width = ${pixelWidth};`);
    scadLines.push(`pixel_height = ${pixelHeight};`);
    scadLines.push(``);
    
    colorNames.forEach((colorName, idx) => {
        const hex = colorEntryToHex(image.partList[idx].target).substring(1);
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        
        scadLines.push(`// Color: ${image.partList[idx].target.name}`);
        scadLines.push(`color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])`);
        scadLines.push(`  scale([pixel_width, pixel_width, pixel_height])`);
        scadLines.push(`    surface(file = "mask_${colorName}.png", invert = true);`);
        scadLines.push(``);
    });
    
    const scadContent = scadLines.join('\n');
    
    // Create ZIP file with masks and .scad file
    const files: Record<string, Blob | string> = {
        [`${filename}.scad`]: scadContent
    };
    
    // Add mask images as blobs
    for (const [maskFilename, base64] of Object.entries(maskImages)) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        files[maskFilename] = new Blob([bytes], { type: 'image/png' });
    }
    
    createZipAndDownload(filename + '_openscad.zip', files);
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
}

function createZipAndDownload(filename: string, files: Record<string, string | Blob>): void {
    loadJSZipAnd(() => {
        const zip = new (window as any).JSZip();
        
        for (const [path, content] of Object.entries(files)) {
            zip.file(path, content);
        }
        
        zip.generateAsync({ type: 'blob' }).then((blob: Blob) => {
            downloadBlob(blob, filename);
        });
    });
}

function loadJSZipAnd(callback: () => void): void {
    const tagName = 'jszip-script-tag';
    const existing = document.getElementById(tagName);
    
    if (existing) {
        callback();
    } else {
        const script = document.createElement('script');
        script.id = tagName;
        script.onload = () => callback();
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        document.head.appendChild(script);
    }
}

function downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
