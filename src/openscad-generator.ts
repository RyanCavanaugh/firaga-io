import { PartListImage } from "./image-utils";

declare const JSZip: any;
declare const saveAs: typeof import("file-saver").saveAs;

export async function generateOpenSCADMasks(image: PartListImage, filename: string) {
    // Load JSZip if not already loaded
    await loadJSZip();
    
    const zip = new JSZip();
    
    // Create one black/white PNG for each color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const part = image.partList[colorIdx];
        const maskImage = createMaskImage(image, colorIdx);
        const blob = await canvasToBlob(maskImage);
        
        // Sanitize color name for filename
        const safeName = part.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        zip.file(`mask_${colorIdx}_${safeName}.png`, blob);
    }
    
    // Create OpenSCAD file
    const scadContent = createOpenSCADFile(image);
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate and download ZIP
    const zipBlob = await zip.generateAsync({ type: "blob" });
    saveAs(zipBlob, `${filename}_openscad.zip`);
}

function createMaskImage(image: PartListImage, colorIdx: number): HTMLCanvasElement {
    const canvas = document.createElement("canvas");
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext("2d")!;
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const isColor = image.pixels[y][x] === colorIdx;
            
            // White where the color is, black elsewhere
            const value = isColor ? 255 : 0;
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}

function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error("Failed to create blob from canvas"));
            }
        }, "image/png");
    });
}

function createOpenSCADFile(image: PartListImage): string {
    const parts: string[] = [];
    
    // Add comment header
    parts.push(`// OpenSCAD file for ${image.width}x${image.height} pixel art`);
    parts.push(`// Generated by firaga.io\n`);
    
    // Add module for each color layer
    image.partList.forEach((part, idx) => {
        const safeName = part.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        const r = part.target.r / 255;
        const g = part.target.g / 255;
        const b = part.target.b / 255;
        
        parts.push(`// Color: ${part.target.name}`);
        parts.push(`module layer_${idx}() {`);
        parts.push(`  color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])`);
        parts.push(`  surface(file = "mask_${idx}_${safeName}.png", center = true, invert = true);`);
        parts.push(`}\n`);
    });
    
    // Combine all layers
    parts.push(`// Combine all layers`);
    parts.push(`union() {`);
    image.partList.forEach((_, idx) => {
        parts.push(`  layer_${idx}();`);
    });
    parts.push(`}`);
    
    return parts.join('\n');
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    
    if (scriptEl === null) {
        return new Promise((resolve, reject) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error("Failed to load JSZip"));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}
