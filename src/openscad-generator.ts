import { saveAs } from 'file-saver';
import JSZip from 'jszip';
import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

export function generateOpenSCADMasks(image: PartListImage, filename: string) {
    const zip = new JSZip();
    const promises: Promise<void>[] = [];
    
    // Generate one black/white image per color
    image.partList.forEach((part, colorIdx) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = 'black';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert to PNG blob and add to zip
        const promise = new Promise<void>((resolve) => {
            canvas.toBlob((blob) => {
                if (blob) {
                    const safeName = part.target.name.replace(/[^a-zA-Z0-9]/g, '_');
                    zip.file(`mask_${colorIdx}_${safeName}.png`, blob);
                }
                resolve();
            }, 'image/png');
        });
        promises.push(promise);
    });
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image);
    zip.file(`${filename}.scad`, scadContent);
    
    // Wait for all blobs to be created, then generate and save zip
    Promise.all(promises).then(() => {
        zip.generateAsync({ type: 'blob' }).then((blob) => {
            saveAs(blob, `${filename}_openscad.zip`);
        });
    });
}

function generateOpenSCADFile(image: PartListImage): string {
    let scad = '// OpenSCAD 3D display of pixel art\n';
    scad += '// Generated by Firaga.io\n\n';
    
    scad += `width = ${image.width};\n`;
    scad += `height = ${image.height};\n`;
    scad += `pixel_size = 2.5; // mm per pixel\n`;
    scad += `layer_height = 0.5; // mm height per color layer\n\n`;
    
    scad += 'module pixel_layer(image_file, color_rgb, layer_num) {\n';
    scad += '    color(color_rgb)\n';
    scad += '    translate([0, 0, layer_num * layer_height])\n';
    scad += '    scale([pixel_size, pixel_size, layer_height])\n';
    scad += '    surface(file = image_file, center = false, invert = true);\n';
    scad += '}\n\n';
    
    scad += '// Render all color layers\n';
    image.partList.forEach((part, colorIdx) => {
        const safeName = part.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        const hex = colorEntryToHex(part.target);
        // Convert hex to RGB 0-1 range
        const r = parseInt(hex.substring(1, 3), 16) / 255;
        const g = parseInt(hex.substring(3, 5), 16) / 255;
        const b = parseInt(hex.substring(5, 7), 16) / 255;
        
        scad += `pixel_layer("mask_${colorIdx}_${safeName}.png", [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}], ${colorIdx});\n`;
    });
    
    return scad;
}
