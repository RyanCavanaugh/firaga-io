import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

declare const JSZip: any;

export interface OpenSCADSettings {
    filename: string;
}

/**
 * Generates an OpenSCAD masks format as a ZIP file containing:
 * - One monochrome heightmap image per color
 * - An OpenSCAD file that loads and combines all images
 */
export async function generateOpenSCAD(image: PartListImage, settings: OpenSCADSettings): Promise<void> {
    await loadJSZip();
    
    const zip = new JSZip();
    const scadContent = createOpenSCADFile(image);
    
    // Add the .scad file
    zip.file(`${settings.filename}.scad`, scadContent);
    
    // Generate and add heightmap images for each color
    for (let i = 0; i < image.partList.length; i++) {
        const part = image.partList[i];
        const imageData = createHeightmapImage(image, i);
        const blob = await imageToPNGBlob(imageData);
        zip.file(`color_${i}_${sanitizeFilename(part.target.name)}.png`, blob);
    }
    
    // Generate the ZIP file and download it
    const zipBlob = await zip.generateAsync({ type: "blob" });
    downloadFile(zipBlob, `${settings.filename}_openscad.zip`);
}

function createOpenSCADFile(image: PartListImage): string {
    const lines: string[] = [];
    
    lines.push(`// Generated by firaga.io`);
    lines.push(`// 3D visualization of pixel art`);
    lines.push(``);
    lines.push(`// Image dimensions: ${image.width} x ${image.height}`);
    lines.push(``);
    
    // Add color modules
    image.partList.forEach((part, idx) => {
        const hex = colorEntryToHex(part.target).substring(1);
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        
        lines.push(`// Color: ${part.target.name}`);
        lines.push(`module color_${idx}() {`);
        lines.push(`    color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])`);
        lines.push(`    surface(file = "color_${idx}_${sanitizeFilename(part.target.name)}.png", center = true, invert = true);`);
        lines.push(`}`);
        lines.push(``);
    });
    
    // Create the main assembly
    lines.push(`// Main assembly`);
    lines.push(`union() {`);
    image.partList.forEach((_, idx) => {
        lines.push(`    color_${idx}();`);
    });
    lines.push(`}`);
    
    return lines.join('\n');
}

function createHeightmapImage(image: PartListImage, colorIndex: number): ImageData {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Failed to get canvas context');
    }
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    // Create a black/white heightmap where white = this color, black = empty
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const pixelColor = image.pixels[y][x];
            
            // White (255) where this color exists, black (0) otherwise
            const value = pixelColor === colorIndex ? 255 : 0;
            
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A (fully opaque)
        }
    }
    
    return imageData;
}

async function imageToPNGBlob(imageData: ImageData): Promise<Blob> {
    const canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Failed to get canvas context');
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob from canvas'));
            }
        }, 'image/png');
    });
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function downloadFile(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    
    if (scriptEl === null) {
        return new Promise((resolve, reject) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error('Failed to load JSZip'));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}
