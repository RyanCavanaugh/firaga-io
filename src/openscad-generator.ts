import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export interface OpenSCADSettings {
    filename: string;
    pixelSize: number;
    layerHeight: number;
}

/**
 * Generate an OpenSCAD masks ZIP file containing:
 * - One monochrome image per color showing which pixels are filled
 * - An OpenSCAD .scad file that loads and combines all images
 */
export async function generateOpenSCADMasks(
    image: PartListImage,
    settings: OpenSCADSettings
): Promise<void> {
    // Dynamically import JSZip
    const JSZip = await loadJSZip();
    const zip = new JSZip();
    
    const { pixelSize, layerHeight } = settings;
    const scadParts: string[] = [];
    
    // Generate one mask image per color
    for (let i = 0; i < image.partList.length; i++) {
        const part = image.partList[i];
        const maskCanvas = createMaskImage(image, i);
        const blob = await canvasToBlob(maskCanvas);
        const filename = `mask_${i}_${sanitizeFilename(part.target.name)}.png`;
        
        zip.file(filename, blob);
        
        const color = colorEntryToHex(part.target);
        const rgb = hexToRgb(color);
        
        scadParts.push(`
// ${part.target.name} (${part.count} pixels)
color([${rgb.r}, ${rgb.g}, ${rgb.b}])
translate([0, 0, ${i * layerHeight}])
scale([${pixelSize}, ${pixelSize}, ${layerHeight}])
surface(file = "${filename}", center = true, invert = true);
`);
    }
    
    // Create the OpenSCAD file
    const scadContent = `// Generated by firaga.io
// Image: ${image.width}x${image.height} pixels
// Colors: ${image.partList.length}

${scadParts.join('\n')}
`;
    
    zip.file(`${settings.filename}.scad`, scadContent);
    
    // Generate and download the ZIP file
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    downloadFile(zipBlob, `${settings.filename}_openscad.zip`);
}

/**
 * Create a monochrome mask image for a specific color index.
 * White pixels = filled, Black pixels = empty
 */
function createMaskImage(image: PartListImage, colorIndex: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const pixelIndex = (y * image.width + x) * 4;
            const isColor = image.pixels[y][x] === colorIndex;
            
            // White for this color, black otherwise
            const value = isColor ? 255 : 0;
            imageData.data[pixelIndex] = value;     // R
            imageData.data[pixelIndex + 1] = value; // G
            imageData.data[pixelIndex + 2] = value; // B
            imageData.data[pixelIndex + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}

function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to convert canvas to blob'));
            }
        }, 'image/png');
    });
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) {
        return { r: 0.5, g: 0.5, b: 0.5 };
    }
    return {
        r: parseInt(result[1], 16) / 255,
        g: parseInt(result[2], 16) / 255,
        b: parseInt(result[3], 16) / 255
    };
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
}

function downloadFile(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

let jszipPromise: Promise<typeof import('jszip')> | undefined;

async function loadJSZip(): Promise<typeof import('jszip')> {
    if (jszipPromise) {
        return jszipPromise;
    }
    
    jszipPromise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => {
            // JSZip loads as a global
            resolve((window as any).JSZip);
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
    
    return jszipPromise;
}
