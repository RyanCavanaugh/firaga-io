import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";
import JSZip from "jszip";

export type OpenSCADSettings = {
    pixelSize: number; // XY size of each pixel in mm
    heightPerLayer: number; // Z-height increment per color layer in mm
};

/**
 * Generates a ZIP file containing:
 * - One monochrome PNG per color (black/white mask)
 * - An OpenSCAD file that loads all images and combines them into a 3D display
 */
export async function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADSettings): Promise<Blob> {
    const { width, height, pixels, partList } = image;
    const { pixelSize, heightPerLayer } = settings;

    const zip = new JSZip();

    // Generate one mask image per color
    for (let colorIndex = 0; colorIndex < partList.length; colorIndex++) {
        const entry = partList[colorIndex];
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d')!;

        // Fill with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);

        // Draw black pixels for this color
        ctx.fillStyle = 'black';
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (pixels[y][x] === colorIndex) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        // Convert canvas to blob
        const blob = await new Promise<Blob>((resolve) => {
            canvas.toBlob((b) => resolve(b!), 'image/png');
        });

        const sanitizedName = entry.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        zip.file(`mask_${colorIndex}_${sanitizedName}.png`, blob);
    }

    // Generate OpenSCAD file
    let scadContent = `// Generated by firaga.io
// Pixel-art 3D model with ${partList.length} colors

`;

    // Add color definitions as comments
    scadContent += `// Color definitions:\n`;
    for (let i = 0; i < partList.length; i++) {
        const entry = partList[i];
        const hexColor = colorEntryToHex(entry.target);
        scadContent += `// ${i}: ${entry.target.name} (${hexColor})\n`;
    }
    scadContent += '\n';

    // Parameters
    scadContent += `pixel_size = ${pixelSize}; // mm per pixel
height_per_layer = ${heightPerLayer}; // mm height per color layer
image_width = ${width};
image_height = ${height};

`;

    // Module for creating a layer from a heightmap
    scadContent += `module color_layer(filename, z_offset, layer_color) {
    color(layer_color)
    translate([0, 0, z_offset])
    surface(file = filename, center = true, invert = true);
}

`;

    // Scale and combine all layers
    scadContent += `scale([pixel_size, pixel_size, height_per_layer]) {\n`;
    
    for (let i = 0; i < partList.length; i++) {
        const entry = partList[i];
        const sanitizedName = entry.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `mask_${i}_${sanitizedName}.png`;
        const hexColor = colorEntryToHex(entry.target);
        
        // Convert hex to RGB values (0-1 range)
        const r = parseInt(hexColor.substring(1, 3), 16) / 255;
        const g = parseInt(hexColor.substring(3, 5), 16) / 255;
        const b = parseInt(hexColor.substring(5, 7), 16) / 255;
        
        scadContent += `    color_layer("${filename}", ${i}, [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}]);\n`;
    }
    
    scadContent += `}\n`;

    zip.file('model.scad', scadContent);

    return await zip.generateAsync({ type: 'blob' });
}
