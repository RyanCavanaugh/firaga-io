import { PartListImage } from './image-utils';
import { saveAs } from 'file-saver';

export function generateOpenSCADMasks(image: PartListImage, filename: string) {
    const files: Array<{ path: string, content: Uint8Array | string }> = [];
    
    // Generate one PNG mask per color
    image.partList.forEach((entry, colorIdx) => {
        const maskData = generateMaskImage(image, colorIdx);
        files.push({
            path: `mask_${colorIdx}_${sanitizeFilename(entry.target.name)}.png`,
            content: maskData
        });
    });
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, filename);
    files.push({
        path: `${filename}.scad`,
        content: scadContent
    });
    
    // Create zip file
    const zip = createZipFile(files);
    const blob = new Blob([zip], { type: 'application/zip' });
    saveAs(blob, `${filename}_openscad.zip`);
}

function generateMaskImage(image: PartListImage, colorIdx: number): Uint8Array {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const idx = (y * image.width + x) * 4;
            const isColor = image.pixels[y][x] === colorIdx;
            
            // White for pixels of this color, black for others
            const value = isColor ? 255 : 0;
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Convert canvas to PNG data
    const dataUrl = canvas.toDataURL('image/png');
    const base64 = dataUrl.split(',')[1];
    const binary = atob(base64);
    const array = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        array[i] = binary.charCodeAt(i);
    }
    
    return array;
}

function generateOpenSCADFile(image: PartListImage, filename: string): string {
    const pixelSize = 1; // Size of each pixel in mm
    const maxHeight = 10; // Maximum height in mm
    
    let scadCode = `// OpenSCAD file for ${filename}
// Generated by Firaga.io

// Parameters
pixel_size = ${pixelSize};
max_height = ${maxHeight};
image_width = ${image.width};
image_height = ${image.height};

// Import and combine all color layers
union() {
`;
    
    image.partList.forEach((entry, colorIdx) => {
        const r = entry.target.r / 255;
        const g = entry.target.g / 255;
        const b = entry.target.b / 255;
        const maskFile = `mask_${colorIdx}_${sanitizeFilename(entry.target.name)}.png`;
        
        scadCode += `    // ${entry.target.name} (${entry.count} pixels)
    color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
    translate([0, 0, ${colorIdx * 0.01}]) // Slight z-offset to prevent z-fighting
    surface(file = "${maskFile}", center = true, invert = false, convexity = 10);
    
`;
    });
    
    scadCode += `}

// Alternative: Stack colors vertically
/*
union() {
`;
    
    image.partList.forEach((entry, colorIdx) => {
        const r = entry.target.r / 255;
        const g = entry.target.g / 255;
        const b = entry.target.b / 255;
        const maskFile = `mask_${colorIdx}_${sanitizeFilename(entry.target.name)}.png`;
        
        scadCode += `    color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
    translate([0, 0, ${colorIdx * (maxHeight / image.partList.length)}])
    scale([pixel_size, pixel_size, max_height / 255])
    surface(file = "${maskFile}", center = true, invert = false);
    
`;
    });
    
    scadCode += `}
*/
`;
    
    return scadCode;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

// Simple zip file generator
function createZipFile(files: Array<{ path: string, content: Uint8Array | string }>): Uint8Array {
    const encoder = new TextEncoder();
    
    const parts: Uint8Array[] = [];
    let centralDir: Uint8Array[] = [];
    let offset = 0;
    
    for (const file of files) {
        const data = typeof file.content === 'string' 
            ? encoder.encode(file.content) 
            : file.content;
        const pathBytes = encoder.encode(file.path);
        
        // Local file header
        const header = new Uint8Array(30 + pathBytes.length);
        const view = new DataView(header.buffer);
        view.setUint32(0, 0x04034b50, true); // Local file header signature
        view.setUint16(4, 20, true); // Version needed to extract
        view.setUint16(6, 0, true); // General purpose bit flag
        view.setUint16(8, 0, true); // Compression method (0 = no compression)
        view.setUint16(10, 0, true); // File last modification time
        view.setUint16(12, 0, true); // File last modification date
        view.setUint32(14, crc32(data), true); // CRC-32
        view.setUint32(18, data.length, true); // Compressed size
        view.setUint32(22, data.length, true); // Uncompressed size
        view.setUint16(26, pathBytes.length, true); // File name length
        view.setUint16(28, 0, true); // Extra field length
        header.set(pathBytes, 30);
        
        parts.push(header);
        parts.push(data);
        
        // Central directory entry
        const cdEntry = new Uint8Array(46 + pathBytes.length);
        const cdView = new DataView(cdEntry.buffer);
        cdView.setUint32(0, 0x02014b50, true); // Central directory header signature
        cdView.setUint16(4, 20, true); // Version made by
        cdView.setUint16(6, 20, true); // Version needed to extract
        cdView.setUint16(8, 0, true); // General purpose bit flag
        cdView.setUint16(10, 0, true); // Compression method
        cdView.setUint16(12, 0, true); // File last modification time
        cdView.setUint16(14, 0, true); // File last modification date
        cdView.setUint32(16, crc32(data), true); // CRC-32
        cdView.setUint32(20, data.length, true); // Compressed size
        cdView.setUint32(24, data.length, true); // Uncompressed size
        cdView.setUint16(28, pathBytes.length, true); // File name length
        cdView.setUint16(30, 0, true); // Extra field length
        cdView.setUint16(32, 0, true); // File comment length
        cdView.setUint16(34, 0, true); // Disk number start
        cdView.setUint16(36, 0, true); // Internal file attributes
        cdView.setUint32(38, 0, true); // External file attributes
        cdView.setUint32(42, offset, true); // Relative offset of local header
        cdEntry.set(pathBytes, 46);
        
        centralDir.push(cdEntry);
        offset += header.length + data.length;
    }
    
    // End of central directory
    const cdSize = centralDir.reduce((sum, entry) => sum + entry.length, 0);
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 0x06054b50, true); // End of central directory signature
    eocdView.setUint16(4, 0, true); // Disk number
    eocdView.setUint16(6, 0, true); // Disk number where central directory starts
    eocdView.setUint16(8, files.length, true); // Number of central directory records on this disk
    eocdView.setUint16(10, files.length, true); // Total number of central directory records
    eocdView.setUint32(12, cdSize, true); // Size of central directory
    eocdView.setUint32(16, offset, true); // Offset of start of central directory
    eocdView.setUint16(20, 0, true); // Comment length
    
    // Combine all parts
    const totalSize = parts.reduce((sum, p) => sum + p.length, 0) + cdSize + eocd.length;
    const result = new Uint8Array(totalSize);
    let pos = 0;
    for (const part of parts) {
        result.set(part, pos);
        pos += part.length;
    }
    for (const entry of centralDir) {
        result.set(entry, pos);
        pos += entry.length;
    }
    result.set(eocd, pos);
    
    return result;
}

function crc32(data: Uint8Array): number {
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < data.length; i++) {
        crc ^= data[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));
        }
    }
    return ~crc >>> 0;
}
