import { PartListImage } from "./image-utils";
import { saveAs } from "file-saver";

export interface OpenSCADMasksSettings {
    filename: string;
    pixelHeight: number;
}

export async function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADMasksSettings) {
    await loadJSZipAnd(() => generateOpenSCADMasksWorker(image, settings));
}

async function loadJSZipAnd(func: () => void) {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        const tag = document.createElement("script");
        tag.id = tagName;
        tag.onload = () => {
            func();
        };
        tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        document.head.appendChild(tag);
    } else {
        func();
    }
}

function generateOpenSCADMasksWorker(image: PartListImage, settings: OpenSCADMasksSettings) {
    const zip = new JSZip();
    
    // Generate a PNG mask for each color
    const imageFiles: string[] = [];
    
    image.partList.forEach((part, colorIdx) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw black pixels for this color
        ctx.fillStyle = 'black';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to blob and add to zip
        const filename = `mask_${sanitizeFilename(part.target.name)}.png`;
        imageFiles.push(filename);
        
        canvas.toBlob((blob) => {
            if (blob) {
                zip.file(filename, blob);
            }
        });
    });
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, settings, imageFiles);
    zip.file(`${settings.filename}.scad`, scadContent);
    
    // Wait a bit for all blobs to be created, then generate zip
    setTimeout(() => {
        zip.generateAsync({ type: "blob" }).then((blob) => {
            saveAs(blob, `${settings.filename}.zip`);
        });
    }, 500);
}

function generateOpenSCADFile(
    image: PartListImage, 
    settings: OpenSCADMasksSettings,
    imageFiles: string[]
): string {
    let scad = `// Generated by firaga.io
// Image dimensions: ${image.width} x ${image.height}

`;

    // Add color information as comments
    image.partList.forEach((part, idx) => {
        scad += `// Color ${idx}: ${part.target.name} (${part.count} pixels)\n`;
    });
    
    scad += `\n`;
    
    // Create modules for each color layer
    image.partList.forEach((part, idx) => {
        scad += `module layer_${idx}() {\n`;
        scad += `  scale([1, 1, ${settings.pixelHeight}]) {\n`;
        scad += `    surface(file = "${imageFiles[idx]}", center = true, invert = true);\n`;
        scad += `  }\n`;
        scad += `}\n\n`;
    });
    
    // Create the combined model with colors
    scad += `// Combined model\n`;
    scad += `union() {\n`;
    
    image.partList.forEach((part, idx) => {
        const hex = rgbToHex(part.target.r, part.target.g, part.target.b);
        const [r, g, b] = hexToRgb(hex);
        scad += `  color([${r/255}, ${g/255}, ${b/255}]) layer_${idx}();\n`;
    });
    
    scad += `}\n`;
    
    return scad;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function rgbToHex(r: number, g: number, b: number): string {
    return '#' + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}

function hexToRgb(hex: string): [number, number, number] {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result 
        ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)]
        : [0, 0, 0];
}

// Minimal JSZip interface
declare class JSZip {
    constructor();
    file(name: string, content: string | Blob): void;
    folder(name: string): JSZip | null;
    generateAsync(options: { type: string }): Promise<Blob>;
}

declare const JSZip: {
    new(): JSZip;
};
