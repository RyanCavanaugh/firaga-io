import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

declare const JSZip: any;

export interface OpenSCADSettings {
    height: number; // Height in mm for the 3D extrusion
    pixelSize: number; // Size of each pixel in mm
    filename: string;
}

export async function generateOpenSCAD(image: PartListImage, settings: OpenSCADSettings) {
    await loadJSZip();
    const zip = new JSZip();

    const { width, height, partList, pixels } = image;

    // Generate one monochrome image per color
    const imageFiles: { filename: string, colorName: string }[] = [];

    for (let colorIdx = 0; colorIdx < partList.length; colorIdx++) {
        const color = partList[colorIdx].target;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d')!;

        // Create a monochrome image (black for pixels of this color, white for others)
        const imageData = ctx.createImageData(width, height);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = (y * width + x) * 4;
                if (pixels[y][x] === colorIdx) {
                    // Black pixel (filled)
                    imageData.data[idx] = 0;
                    imageData.data[idx + 1] = 0;
                    imageData.data[idx + 2] = 0;
                    imageData.data[idx + 3] = 255;
                } else {
                    // White pixel (empty)
                    imageData.data[idx] = 255;
                    imageData.data[idx + 1] = 255;
                    imageData.data[idx + 2] = 255;
                    imageData.data[idx + 3] = 255;
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // Convert canvas to PNG blob
        const blob = await new Promise<Blob>((resolve) => {
            canvas.toBlob((b) => resolve(b!), 'image/png');
        });

        const sanitizedName = sanitizeFilename(color.name);
        const filename = `mask_${colorIdx}_${sanitizedName}.png`;
        imageFiles.push({ filename, colorName: color.name });
        zip.file(filename, blob);
    }

    // Generate the OpenSCAD file
    const scadContent = generateSCADFile(imageFiles, width, height, settings);
    zip.file(`${settings.filename}.scad`, scadContent);

    // Generate and download the zip file
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    downloadBlob(zipBlob, `${settings.filename}.zip`);
}

function generateSCADFile(
    imageFiles: { filename: string, colorName: string }[],
    width: number,
    height: number,
    settings: OpenSCADSettings
): string {
    const { pixelSize, height: extrusionHeight } = settings;

    let scadCode = `// Generated by firaga.io
// Image size: ${width}x${height} pixels
// Pixel size: ${pixelSize}mm
// Extrusion height: ${extrusionHeight}mm

`;

    // Add each color layer
    imageFiles.forEach(({ filename, colorName }, idx) => {
        scadCode += `
// Color: ${colorName}
module layer_${idx}() {
    color([${Math.random()}, ${Math.random()}, ${Math.random()}]) {
        linear_extrude(height = ${extrusionHeight}) {
            scale([${pixelSize}, ${pixelSize}, 1]) {
                surface(file = "${filename}", center = true, invert = true);
            }
        }
    }
}
`;
    });

    // Combine all layers
    scadCode += `
// Combine all layers
union() {
`;

    imageFiles.forEach((_, idx) => {
        scadCode += `    layer_${idx}();\n`;
    });

    scadCode += `}
`;

    return scadCode;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9]/g, '_');
}

function downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

async function loadJSZip() {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        await new Promise<void>((resolve) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}
