import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export interface OpenSCADMasksSettings {
    pixelHeight: number;
    baseThickness: number;
}

/**
 * Generates a ZIP file containing OpenSCAD masks:
 * - One monochrome (black/white) PNG image per color
 * - An OpenSCAD file that loads the images as heightmaps and combines them
 */
export async function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADMasksSettings): Promise<Blob> {
    const { pixelHeight, baseThickness } = settings;
    const files: Array<{ path: string; content: Uint8Array | string }> = [];
    
    // Generate one mask image per color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const entry = image.partList[colorIdx];
        const maskData = generateMaskImage(image, colorIdx);
        const fileName = `mask_${sanitizeFilename(entry.target.name)}_${colorIdx}.png`;
        files.push({ path: fileName, content: maskData });
    }
    
    // Generate the OpenSCAD file
    const scadContent = generateOpenSCADFile(image, pixelHeight, baseThickness);
    files.push({ path: "model.scad", content: scadContent });
    
    // Create ZIP file
    return createZipFile(files);
}

/**
 * Creates a monochrome PNG image where pixels of the specified color are white,
 * and all other pixels are black.
 */
function generateMaskImage(image: PartListImage, colorIdx: number): Uint8Array {
    const { width, height, pixels } = image;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Failed to get canvas context');
    }
    
    const imageData = ctx.createImageData(width, height);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const isColorMatch = pixels[y][x] === colorIdx;
            const value = isColorMatch ? 255 : 0;
            
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Convert canvas to PNG blob synchronously using data URL
    const dataUrl = canvas.toDataURL('image/png');
    const base64 = dataUrl.split(',')[1];
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    
    return bytes;
}

/**
 * Generates an OpenSCAD file that loads all mask images as heightmaps
 * and combines them with different colors.
 */
function generateOpenSCADFile(image: PartListImage, pixelHeight: number, baseThickness: number): string {
    const { width, height, partList } = image;
    const layers: string[] = [];
    
    // Add base layer
    layers.push(`// Base layer
color([0.9, 0.9, 0.9])
  cube([${width}, ${height}, ${baseThickness}]);
`);
    
    // Add a colored layer for each mask
    for (let colorIdx = 0; colorIdx < partList.length; colorIdx++) {
        const entry = partList[colorIdx];
        const fileName = `mask_${sanitizeFilename(entry.target.name)}_${colorIdx}.png`;
        const color = entry.target;
        const rgbColor = hexToRgb(colorEntryToHex(color));
        
        layers.push(`// ${entry.target.name} (${entry.count} pixels)
translate([0, 0, ${baseThickness}])
  color([${rgbColor.r / 255}, ${rgbColor.g / 255}, ${rgbColor.b / 255}])
    surface(file = "${fileName}", center = false, convexity = 5)
      scale([1, 1, ${pixelHeight / 255}]);
`);
    }
    
    return `// Generated by firaga.io
// Image size: ${width}x${height} pixels
// Pixel height: ${pixelHeight}mm
// Base thickness: ${baseThickness}mm

union() {
${layers.map(l => '  ' + l.split('\n').join('\n  ')).join('\n')}
}
`;
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) {
        return { r: 0, g: 0, b: 0 };
    }
    return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    };
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
}

async function createZipFile(files: Array<{ path: string; content: Uint8Array | string }>): Promise<Blob> {
    const encoder = new TextEncoder();
    const zipData: number[] = [];
    const centralDirectory: number[] = [];
    let offset = 0;
    
    for (const file of files) {
        const content = typeof file.content === 'string' 
            ? encoder.encode(file.content)
            : file.content;
        const fileName = encoder.encode(file.path);
        
        // Local file header
        const localHeader = [
            0x50, 0x4b, 0x03, 0x04, // Signature
            0x14, 0x00, // Version needed
            0x00, 0x00, // Flags
            0x00, 0x00, // Compression method (stored)
            0x00, 0x00, // Mod time
            0x00, 0x00, // Mod date
            ...uint32ToBytes(crc32(content)), // CRC-32
            ...uint32ToBytes(content.length), // Compressed size
            ...uint32ToBytes(content.length), // Uncompressed size
            ...uint16ToBytes(fileName.length), // File name length
            0x00, 0x00 // Extra field length
        ];
        
        zipData.push(...localHeader);
        zipData.push(...fileName);
        zipData.push(...content);
        
        // Central directory entry
        const centralEntry = [
            0x50, 0x4b, 0x01, 0x02, // Signature
            0x14, 0x00, // Version made by
            0x14, 0x00, // Version needed
            0x00, 0x00, // Flags
            0x00, 0x00, // Compression method
            0x00, 0x00, // Mod time
            0x00, 0x00, // Mod date
            ...uint32ToBytes(crc32(content)), // CRC-32
            ...uint32ToBytes(content.length), // Compressed size
            ...uint32ToBytes(content.length), // Uncompressed size
            ...uint16ToBytes(fileName.length), // File name length
            0x00, 0x00, // Extra field length
            0x00, 0x00, // File comment length
            0x00, 0x00, // Disk number
            0x00, 0x00, // Internal attributes
            0x00, 0x00, 0x00, 0x00, // External attributes
            ...uint32ToBytes(offset) // Relative offset
        ];
        
        centralDirectory.push(...centralEntry);
        centralDirectory.push(...fileName);
        
        offset += localHeader.length + fileName.length + content.length;
    }
    
    const centralDirOffset = offset;
    zipData.push(...centralDirectory);
    
    // End of central directory
    const endOfCentralDir = [
        0x50, 0x4b, 0x05, 0x06, // Signature
        0x00, 0x00, // Disk number
        0x00, 0x00, // Central directory start disk
        ...uint16ToBytes(files.length), // Entries on this disk
        ...uint16ToBytes(files.length), // Total entries
        ...uint32ToBytes(centralDirectory.length), // Central directory size
        ...uint32ToBytes(centralDirOffset), // Central directory offset
        0x00, 0x00 // Comment length
    ];
    
    zipData.push(...endOfCentralDir);
    
    return new Blob([new Uint8Array(zipData)], { type: 'application/zip' });
}

function uint16ToBytes(value: number): number[] {
    return [value & 0xff, (value >> 8) & 0xff];
}

function uint32ToBytes(value: number): number[] {
    return [
        value & 0xff,
        (value >> 8) & 0xff,
        (value >> 16) & 0xff,
        (value >> 24) & 0xff
    ];
}

function crc32(data: Uint8Array): number {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i++) {
        crc ^= data[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc >>> 1) ^ (0xedb88320 & -(crc & 1));
        }
    }
    return crc ^ 0xffffffff;
}
