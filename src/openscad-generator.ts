import { PartListImage } from "./image-utils";
import { saveAs } from "file-saver";

export type OpenScadSettings = {
    pixelSize: number;
    heightScale: number;
};

export async function generateOpenScadMasks(
    image: PartListImage,
    settings: OpenScadSettings,
    filename: string
): Promise<void> {
    const JSZip = await loadJSZip();
    const zip = new JSZip();
    
    // Generate one mask image per color
    const maskPromises = image.partList.map(async (part, colorIdx) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white (background)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = '#000000';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to blob
        const blob = await new Promise<Blob>((resolve) => {
            canvas.toBlob((b) => resolve(b!), 'image/png');
        });
        
        const safeName = part.target.name.replace(/[^a-zA-Z0-9]/g, '_');
        zip.file(`mask_${colorIdx}_${safeName}.png`, blob);
        
        return { idx: colorIdx, name: safeName, symbol: part.symbol };
    });
    
    const masks = await Promise.all(maskPromises);
    
    // Generate OpenSCAD file
    const scadLines: string[] = [];
    scadLines.push('// Generated by firaga.io');
    scadLines.push('// 3D pixel art visualization using heightmap masks\n');
    scadLines.push(`pixel_size = ${settings.pixelSize};`);
    scadLines.push(`height_scale = ${settings.heightScale};`);
    scadLines.push(`image_width = ${image.width};`);
    scadLines.push(`image_height = ${image.height};\n`);
    
    scadLines.push('module color_layer(mask_file, color) {');
    scadLines.push('  color(color)');
    scadLines.push('    translate([0, 0, 0])');
    scadLines.push('      scale([pixel_size, pixel_size, height_scale])');
    scadLines.push('        surface(file=mask_file, center=true, invert=true);');
    scadLines.push('}\n');
    
    scadLines.push('union() {');
    masks.forEach((mask, idx) => {
        const hex = getColorHex(image, mask.idx);
        scadLines.push(`  // ${mask.symbol}: ${image.partList[mask.idx].target.name}`);
        scadLines.push(`  color_layer("mask_${mask.idx}_${mask.name}.png", "${hex}");`);
    });
    scadLines.push('}');
    
    const scadContent = scadLines.join('\n');
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate the zip file
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    saveAs(zipBlob, `${filename}_openscad.zip`);
}

function getColorHex(image: PartListImage, colorIdx: number): string {
    const part = image.partList[colorIdx];
    const r = (part.target.r / 255).toFixed(3);
    const g = (part.target.g / 255).toFixed(3);
    const b = (part.target.b / 255).toFixed(3);
    return `${r}, ${g}, ${b}`;
}

async function loadJSZip(): Promise<typeof import('jszip')> {
    // Load JSZip from CDN if not already loaded
    if (typeof (window as any).JSZip === 'undefined') {
        await new Promise<void>((resolve) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => resolve();
            document.head.appendChild(script);
        });
    }
    return (window as any).JSZip;
}
