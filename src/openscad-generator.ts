import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

export interface OpenSCADSettings {
    pixelWidth: number;
    pixelHeight: number;
    maxHeight: number;
    filename: string;
}

export function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADSettings): Blob {
    const files: Record<string, string | Uint8Array> = {};
    
    // Generate one PNG mask per color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const color = image.partList[colorIdx].target;
        const safeName = sanitizeFilename(color.name);
        const pngData = generateMaskPNG(image, colorIdx);
        files[`${safeName}.png`] = pngData;
    }
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, settings);
    files['display.scad'] = scadContent;
    
    return createZip(files);
}

function generateMaskPNG(image: PartListImage, colorIdx: number): Uint8Array {
    // Create a canvas to render the mask
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    
    // Fill with white background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, image.width, image.height);
    
    // Draw black pixels where this color appears
    ctx.fillStyle = 'black';
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            if (image.pixels[y][x] === colorIdx) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    // Convert canvas to PNG
    const dataUrl = canvas.toDataURL('image/png');
    const base64 = dataUrl.split(',')[1];
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

function generateOpenSCADFile(image: PartListImage, settings: OpenSCADSettings): string {
    const lines: string[] = [];
    
    lines.push('// OpenSCAD file generated by Firaga.io');
    lines.push('// This file uses surface() to create a 3D representation of the pixel art');
    lines.push('');
    lines.push(`pixel_width = ${settings.pixelWidth};`);
    lines.push(`pixel_height = ${settings.pixelHeight};`);
    lines.push(`max_height = ${settings.maxHeight};`);
    lines.push(`image_width = ${image.width};`);
    lines.push(`image_height = ${image.height};`);
    lines.push('');
    
    // Add color definitions
    for (let i = 0; i < image.partList.length; i++) {
        const color = image.partList[i].target;
        const hex = colorEntryToHex(color).slice(1); // Remove '#'
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        lines.push(`color_${i} = [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}];`);
    }
    lines.push('');
    
    // Generate modules for each color layer
    for (let i = 0; i < image.partList.length; i++) {
        const color = image.partList[i].target;
        const safeName = sanitizeFilename(color.name);
        
        lines.push(`module layer_${i}() {`);
        lines.push(`    color(color_${i})`);
        lines.push(`    scale([pixel_width, pixel_height, max_height])`);
        lines.push(`    translate([0, 0, ${i * 0.1}])`);
        lines.push(`    surface(file = "${safeName}.png", center = false, invert = true);`);
        lines.push('}');
        lines.push('');
    }
    
    // Generate the final assembly
    lines.push('// Combine all layers');
    lines.push('union() {');
    for (let i = 0; i < image.partList.length; i++) {
        lines.push(`    layer_${i}();`);
    }
    lines.push('}');
    
    return lines.join('\n');
}

function sanitizeFilename(name: string): string {
    return name
        .replace(/[^a-zA-Z0-9-_]/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_|_$/g, '');
}

function createZip(files: Record<string, string | Uint8Array>): Blob {
    const encoder = new TextEncoder();
    const chunks: Uint8Array[] = [];
    const centralDir: Uint8Array[] = [];
    let offset = 0;
    
    for (const [filename, content] of Object.entries(files)) {
        const nameBytes = encoder.encode(filename);
        const contentBytes = typeof content === 'string' ? encoder.encode(content) : content;
        
        // Local file header
        const localHeader = new Uint8Array(30 + nameBytes.length);
        const view = new DataView(localHeader.buffer);
        view.setUint32(0, 0x04034b50, true); // Local file header signature
        view.setUint16(4, 20, true); // Version needed to extract
        view.setUint16(6, 0, true); // General purpose bit flag
        view.setUint16(8, 0, true); // Compression method (0 = no compression)
        view.setUint16(10, 0, true); // File last modification time
        view.setUint16(12, 0, true); // File last modification date
        view.setUint32(14, crc32(contentBytes), true); // CRC-32
        view.setUint32(18, contentBytes.length, true); // Compressed size
        view.setUint32(22, contentBytes.length, true); // Uncompressed size
        view.setUint16(26, nameBytes.length, true); // File name length
        view.setUint16(28, 0, true); // Extra field length
        localHeader.set(nameBytes, 30);
        
        chunks.push(localHeader);
        chunks.push(contentBytes);
        
        // Central directory file header
        const centralHeader = new Uint8Array(46 + nameBytes.length);
        const cdView = new DataView(centralHeader.buffer);
        cdView.setUint32(0, 0x02014b50, true); // Central directory file header signature
        cdView.setUint16(4, 20, true); // Version made by
        cdView.setUint16(6, 20, true); // Version needed to extract
        cdView.setUint16(8, 0, true); // General purpose bit flag
        cdView.setUint16(10, 0, true); // Compression method
        cdView.setUint16(12, 0, true); // File last modification time
        cdView.setUint16(14, 0, true); // File last modification date
        cdView.setUint32(16, crc32(contentBytes), true); // CRC-32
        cdView.setUint32(20, contentBytes.length, true); // Compressed size
        cdView.setUint32(24, contentBytes.length, true); // Uncompressed size
        cdView.setUint16(28, nameBytes.length, true); // File name length
        cdView.setUint16(30, 0, true); // Extra field length
        cdView.setUint16(32, 0, true); // File comment length
        cdView.setUint16(34, 0, true); // Disk number start
        cdView.setUint16(36, 0, true); // Internal file attributes
        cdView.setUint32(38, 0, true); // External file attributes
        cdView.setUint32(42, offset, true); // Relative offset of local header
        centralHeader.set(nameBytes, 46);
        
        centralDir.push(centralHeader);
        offset += localHeader.length + contentBytes.length;
    }
    
    const centralDirSize = centralDir.reduce((sum, arr) => sum + arr.length, 0);
    
    // End of central directory record
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 0x06054b50, true); // End of central directory signature
    eocdView.setUint16(4, 0, true); // Number of this disk
    eocdView.setUint16(6, 0, true); // Disk where central directory starts
    eocdView.setUint16(8, Object.keys(files).length, true); // Number of central directory records on this disk
    eocdView.setUint16(10, Object.keys(files).length, true); // Total number of central directory records
    eocdView.setUint32(12, centralDirSize, true); // Size of central directory
    eocdView.setUint32(16, offset, true); // Offset of start of central directory
    eocdView.setUint16(20, 0, true); // ZIP file comment length
    
    return new Blob([...chunks, ...centralDir, eocd], { type: 'application/zip' });
}

function crc32(data: Uint8Array): number {
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < data.length; i++) {
        crc = crc ^ data[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));
        }
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
}
