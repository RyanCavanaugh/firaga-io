import { PartListImage } from "./image-utils";
import { AppProps } from "./types";
import { getPitch, colorEntryToHex } from "./utils";
import * as FileSaver from 'file-saver';

declare const JSZip: any;

let jszipLoaded = false;

async function loadJSZip(): Promise<void> {
    if (jszipLoaded) return;
    
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => {
            jszipLoaded = true;
            resolve();
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

export async function generateOpenSCADZip(
    image: PartListImage,
    gridSize: AppProps["material"]["size"],
    filename: string
): Promise<void> {
    await loadJSZip();
    
    const pitch = getPitch(gridSize);
    const zip = new JSZip();
    
    const { width, height, partList, pixels } = image;
    const colorMasks: Array<{ filename: string, color: string, name: string, index: number }> = [];
    
    for (let colorIdx = 0; colorIdx < partList.length; colorIdx++) {
        const part = partList[colorIdx];
        const maskData = createColorMask(pixels, width, height, colorIdx);
        const pngBlob = await imageToPngBlob(maskData, width, height);
        
        const safeName = sanitizeFilename(part.target.name);
        const maskFilename = `mask_${colorIdx}_${safeName}.png`;
        zip.file(maskFilename, pngBlob);
        
        const color = colorEntryToHex(part.target).substring(1);
        colorMasks.push({
            filename: maskFilename,
            color: `#${color}`,
            name: part.target.name,
            index: colorIdx
        });
    }
    
    const scadContent = createOpenSCADFile(colorMasks, width, height, pitch);
    zip.file(`${filename}.scad`, scadContent);
    
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    FileSaver.saveAs(zipBlob, `${filename}_openscad.zip`);
}

function createColorMask(
    pixels: ReadonlyArray<ReadonlyArray<number>>,
    width: number,
    height: number,
    colorIdx: number
): Uint8ClampedArray {
    const data = new Uint8ClampedArray(width * height * 4);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const isColorMatch = pixels[y][x] === colorIdx;
            
            const value = isColorMatch ? 255 : 0;
            data[idx] = value;
            data[idx + 1] = value;
            data[idx + 2] = value;
            data[idx + 3] = 255;
        }
    }
    
    return data;
}

async function imageToPngBlob(data: Uint8ClampedArray, width: number, height: number): Promise<Blob> {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Failed to get canvas context');
    
    const imageData = new ImageData(data, width, height);
    ctx.putImageData(imageData, 0, 0);
    
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob'));
            }
        }, 'image/png');
    });
}

function createOpenSCADFile(
    colorMasks: Array<{ filename: string, color: string, name: string, index: number }>,
    width: number,
    height: number,
    pitch: number
): string {
    const pixelHeight = 1.0;
    const baseHeight = 0.5;
    
    return `// Generated by firaga.io
// Image dimensions: ${width}x${height} pixels
// Pixel pitch: ${pitch}mm

pixel_size = ${pitch};
pixel_height = ${pixelHeight};
base_height = ${baseHeight};

module color_layer(image_file, color) {
    surface(file = image_file, center = false, invert = true);
}

// Combine all color layers
union() {
${colorMasks.map(mask => `    // ${mask.name} (${mask.color})
    color("${mask.color}")
        linear_extrude(height = pixel_height)
            scale([pixel_size, pixel_size, 1])
                surface(file = "${mask.filename}", center = false, invert = true);
`).join('\n')}
}

// Optional: Add a base platform
// color("gray")
//     translate([0, 0, -base_height])
//         cube([${width * pitch}, ${height * pitch}, base_height]);
`;
}

function sanitizeFilename(name: string): string {
    return name
        .replace(/[^a-zA-Z0-9_-]/g, '_')
        .replace(/_+/g, '_')
        .substring(0, 50);
}
