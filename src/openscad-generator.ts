import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

declare const JSZip: {
    new(): JSZipInstance;
};

interface JSZipInstance {
    file(name: string, data: Blob | string): void;
    generateAsync(options: { type: 'blob' }): Promise<Blob>;
}

/**
 * Generates an OpenSCAD masks format:
 * A zip file containing one monochrome PNG per color + an OpenSCAD file
 * that uses surface() to create 3D heightmaps.
 */
export async function generateOpenSCADMasks(image: PartListImage): Promise<Blob> {
    await loadJSZip();
    
    const zip = new JSZip();
    
    // Generate one mask image per color
    const maskPromises = image.partList.map((entry, idx) => 
        generateMaskImage(image, idx).then(blob => {
            const filename = `color_${idx}_${sanitizeFilename(entry.target.name)}.png`;
            zip.file(filename, blob);
            return { idx, filename, entry };
        })
    );
    
    const masks = await Promise.all(maskPromises);
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, masks);
    zip.file('model.scad', scadContent);
    
    return zip.generateAsync({ type: 'blob' });
}

function generateMaskImage(image: PartListImage, partIdx: number): Promise<Blob> {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white (transparent areas)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, image.width, image.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = '#000000';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === partIdx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        canvas.toBlob(blob => resolve(blob!), 'image/png');
    });
}

function generateOpenSCADFile(
    image: PartListImage,
    masks: Array<{ idx: number; filename: string; entry: { target: { name: string; r: number; g: number; b: number } } }>
): string {
    const colorModules = masks.map(mask => {
        const colorHex = colorEntryToHex(mask.entry.target);
        const rgb = [
            mask.entry.target.r / 255,
            mask.entry.target.g / 255,
            mask.entry.target.b / 255
        ];
        
        return `// ${mask.entry.target.name}
module color_${mask.idx}() {
    color([${rgb[0].toFixed(3)}, ${rgb[1].toFixed(3)}, ${rgb[2].toFixed(3)}])
    scale([1, 1, 0.2])
    surface(file = "${mask.filename}", center = true, invert = true);
}`;
    }).join('\n\n');

    const calls = masks.map(mask => `color_${mask.idx}();`).join('\n');

    return `// Generated by firaga.io
// Image size: ${image.width} x ${image.height}
// Colors: ${image.partList.length}

${colorModules}

// Render all colors
${calls}
`;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

async function loadJSZip(): Promise<void> {
    return new Promise((resolve, reject) => {
        const tagName = 'jszip-script-tag';
        const scriptEl = document.getElementById(tagName);
        if (scriptEl !== null || typeof JSZip !== 'undefined') {
            resolve();
            return;
        }
        
        const tag = document.createElement('script');
        tag.id = tagName;
        tag.onload = () => resolve();
        tag.onerror = () => reject(new Error('Failed to load JSZip'));
        tag.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        document.head.appendChild(tag);
    });
}
