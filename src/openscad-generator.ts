import { PartListImage } from "./image-utils";

/**
 * Generates an OpenSCAD format zip file with monochrome images and an .scad script.
 */
export async function makeOpenscadZip(image: PartListImage, height: number, filename: string): Promise<void> {
    // Import JSZip library dynamically
    const JSZip = await loadJsZip();
    const zip = new JSZip();

    // Generate monochrome images for each color
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const monochrome = generateMonochromeImage(image, colorIndex);
        zip.file(`color_${colorIndex}.png`, monochrome, { binary: true });
    }

    // Generate the OpenSCAD script
    const scadScript = generateScadScript(image, height);
    zip.file("model.scad", scadScript);

    // Generate and download the zip
    const blob = await zip.generateAsync({ type: "blob" });
    downloadFile(blob, `${filename}.zip`);
}

function generateMonochromeImage(image: PartListImage, targetColorIndex: number): Blob {
    const canvas = document.createElement("canvas");
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Failed to get canvas context");

    // Create white background
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Fill black for pixels matching the target color
    ctx.fillStyle = "black";
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            if (image.pixels[y][x] === targetColorIndex) {
                const idx = (y * image.width + x) * 4;
                imageData.data[idx] = 0; // R
                imageData.data[idx + 1] = 0; // G
                imageData.data[idx + 2] = 0; // B
                imageData.data[idx + 3] = 255; // A
            }
        }
    }
    ctx.putImageData(imageData, 0, 0);

    return new Promise(resolve => {
        canvas.toBlob(blob => {
            if (!blob) throw new Error("Failed to convert canvas to blob");
            resolve(blob);
        }, "image/png");
    });
}

function generateScadScript(image: PartListImage, height: number): string {
    const colorCount = image.partList.length;
    const imageWidth = image.width;
    const imageHeight = image.height;
    const heightMm = height;

    let scadCode = `// Generated by firaga.io
// Image dimensions: ${imageWidth}x${imageHeight}
// Total colors: ${colorCount}
// Height: ${heightMm}mm
//
// This script uses heightmaps to create a 3D model from color layers
// Place all PNG files (color_0.png, color_1.png, etc.) in the same directory as this file

// Function to create 3D shape from heightmap image
module colorShape(colorIndex) {
    scale([${imageWidth}, ${imageHeight}, ${heightMm}])
    linear_extrude(height=1, scale=1)
    surface(file=str("color_", colorIndex, ".png"), center=true, invert=true);
}

// Combine all colors stacked on top of each other
union() {
`;

    for (let i = 0; i < colorCount; i++) {
        const color = image.partList[i];
        const hexColor = ((color.target.r << 16) | (color.target.g << 8) | color.target.b)
            .toString(16)
            .padStart(6, "0")
            .toUpperCase();

        scadCode += `    // Color ${i}: ${color.target.name} (#${hexColor})
    translate([0, 0, ${i * heightMm}])
    color([${(color.target.r / 255).toFixed(3)}, ${(color.target.g / 255).toFixed(3)}, ${(color.target.b / 255).toFixed(3)}])
    colorShape(${i});

`;
    }

    scadCode += `}
`;

    return scadCode;
}

async function loadJsZip(): Promise<typeof JSZip> {
    // Check if JSZip is already loaded
    if ((window as any).JSZip) {
        return (window as any).JSZip;
    }

    return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = () => {
            const JSZip = (window as any).JSZip;
            if (!JSZip) {
                reject(new Error("Failed to load JSZip"));
            } else {
                resolve(JSZip);
            }
        };
        script.onerror = () => reject(new Error("Failed to load JSZip script"));
        document.head.appendChild(script);
    });
}

function downloadFile(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
