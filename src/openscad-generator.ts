import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

declare const JSZip: any;

export type OpenSCADSettings = {
  filename: string;
  layerHeight: number;
  pegHeight: number;
};

export async function generateOpenSCADZip(image: PartListImage, settings: OpenSCADSettings): Promise<void> {
  await loadJSZip();
  
  const zip = new JSZip();
  const { partList, pixels, width, height } = image;

  const maskPromises = partList.map(async (part, colorIdx) => {
    const maskImage = await createMaskImage(pixels, width, height, colorIdx);
    zip.file(`color_${colorIdx}_${sanitizeFilename(part.target.name)}.png`, maskImage);
  });

  await Promise.all(maskPromises);

  const scadContent = createOpenSCADFile(image, settings);
  zip.file(`${settings.filename}.scad`, scadContent);

  const blob = await zip.generateAsync({ type: "blob" });
  downloadFile(blob, `${settings.filename}_openscad.zip`);
}

async function createMaskImage(pixels: ReadonlyArray<ReadonlyArray<number>>, width: number, height: number, colorIdx: number): Promise<Blob> {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  
  if (!ctx) {
    throw new Error("Could not get canvas context");
  }

  const imageData = ctx.createImageData(width, height);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const isColor = pixels[y][x] === colorIdx;
      const value = isColor ? 0 : 255;
      
      imageData.data[idx] = value;
      imageData.data[idx + 1] = value;
      imageData.data[idx + 2] = value;
      imageData.data[idx + 3] = 255;
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
  
  return new Promise<Blob>((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (blob) {
        resolve(blob);
      } else {
        reject(new Error("Failed to create blob from canvas"));
      }
    });
  });
}

function createOpenSCADFile(image: PartListImage, settings: OpenSCADSettings): string {
  const { partList, width, height } = image;
  const { layerHeight, pegHeight } = settings;
  
  const modules: string[] = [];
  
  partList.forEach((part, colorIdx) => {
    const colorHex = colorEntryToHex(part.target);
    const r = parseInt(colorHex.substring(1, 3), 16) / 255;
    const g = parseInt(colorHex.substring(3, 5), 16) / 255;
    const b = parseInt(colorHex.substring(5, 7), 16) / 255;
    
    const filename = `color_${colorIdx}_${sanitizeFilename(part.target.name)}.png`;
    
    modules.push(`module layer_${colorIdx}() {
  color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])
  surface(file = "${filename}", center = true, invert = true);
}`);
  });

  const unionCalls = partList.map((_, idx) => `    layer_${idx}();`).join('\n');

  return `// Generated by firaga.io
// Image: ${width}x${height}
// Layer height: ${layerHeight}mm
// Peg height: ${pegHeight}mm

${modules.join('\n\n')}

union() {
${unionCalls}
}
`;
}

function sanitizeFilename(name: string): string {
  return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function downloadFile(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

async function loadJSZip(): Promise<void> {
  return new Promise((resolve) => {
    if (typeof JSZip !== 'undefined') {
      resolve();
      return;
    }
    
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = () => resolve();
    document.head.appendChild(script);
  });
}
