import { PartListImage } from "./image-utils";
import { colorEntryToHex, nameOfColor } from "./utils";

export interface GenerateOpenSCADSettings {
    filename: string;
    pixelHeight: number;
    baseHeight: number;
}

declare const JSZip: any;

export async function generateOpenSCADMasks(image: PartListImage, settings: GenerateOpenSCADSettings): Promise<void> {
    await loadJSZip();
    
    const zip = new JSZip();
    const { width, height, partList, pixels } = image;
    
    // Generate one mask image per color
    const maskFiles: string[] = [];
    
    for (let colorIndex = 0; colorIndex < partList.length; colorIndex++) {
        const part = partList[colorIndex];
        const maskData = createMaskImage(pixels, width, height, colorIndex);
        const filename = `mask_${colorIndex}_${sanitizeFilename(part.target.name)}.png`;
        maskFiles.push(filename);
        zip.file(filename, maskData.split(',')[1], { base64: true });
    }
    
    // Generate OpenSCAD file
    const scadContent = generateSCADFile(image, maskFiles, settings);
    zip.file(`${settings.filename}.scad`, scadContent);
    
    // Generate the ZIP file and download
    const blob = await zip.generateAsync({ type: "blob" });
    downloadBlob(blob, `${settings.filename}_openscad.zip`);
}

function createMaskImage(
    pixels: ReadonlyArray<ReadonlyArray<number>>,
    width: number,
    height: number,
    targetColorIndex: number
): string {
    // Create a canvas to render the black/white mask
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get 2D context');
    }
    
    const imageData = ctx.createImageData(width, height);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const isTarget = pixels[y][x] === targetColorIndex;
            const value = isTarget ? 0 : 255; // Black for filled, white for empty
            
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL('image/png');
}

function generateSCADFile(
    image: PartListImage,
    maskFiles: string[],
    settings: GenerateOpenSCADSettings
): string {
    const { width, height, partList } = image;
    const { pixelHeight, baseHeight } = settings;
    
    const lines: string[] = [];
    
    // Header comment
    lines.push(`// Generated by firaga.io`);
    lines.push(`// Image size: ${width}x${height} pixels`);
    lines.push(`// Colors: ${partList.length}`);
    lines.push(``);
    
    // Module for creating a heightmap layer from image
    lines.push(`module heightmap_layer(file, color, height) {`);
    lines.push(`    color(color)`);
    lines.push(`    scale([1, 1, height])`);
    lines.push(`    surface(file=file, center=true, invert=true);`);
    lines.push(`}`);
    lines.push(``);
    
    // Base plate
    lines.push(`// Base plate`);
    lines.push(`translate([0, 0, ${baseHeight / 2}])`);
    lines.push(`cube([${width}, ${height}, ${baseHeight}], center=true);`);
    lines.push(``);
    
    // Add each color layer
    partList.forEach((part, index) => {
        const maskFile = maskFiles[index];
        const hex = colorEntryToHex(part.target);
        const colorName = nameOfColor(part.target);
        
        // Convert hex to RGB values (0-1 range)
        const r = parseInt(hex.substring(1, 3), 16) / 255;
        const g = parseInt(hex.substring(3, 5), 16) / 255;
        const b = parseInt(hex.substring(5, 7), 16) / 255;
        
        lines.push(`// Layer ${index + 1}: ${colorName} (${part.count} pixels)`);
        lines.push(`translate([0, 0, ${baseHeight + pixelHeight / 2}])`);
        lines.push(`heightmap_layer("${maskFile}", [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}], ${pixelHeight});`);
        lines.push(``);
    });
    
    return lines.join('\n');
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    
    if (scriptEl === null) {
        return new Promise((resolve, reject) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error("Failed to load JSZip"));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}
