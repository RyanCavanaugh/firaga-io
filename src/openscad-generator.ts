import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";
import JSZip from "jszip";

export interface OpenSCADSettings {
    pitch: number;
    height: number;
    filename: string;
}

export async function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADSettings): Promise<Blob> {
    const files: Array<{ name: string; content: string }> = [];
    
    // Create one mask image per color
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const color = image.partList[colorIndex];
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white (background)
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Fill pixels of this color with black
        ctx.fillStyle = 'black';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIndex) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to blob (will be PNG)
        const imageDataURL = canvas.toDataURL('image/png');
        const base64Data = imageDataURL.split(',')[1];
        const filename = `mask_${colorIndex}_${sanitizeFilename(color.target.name)}.png`;
        
        files.push({
            name: filename,
            content: base64Data
        });
    }
    
    // Create the OpenSCAD file
    const scadContent = generateSCADFile(image, settings);
    files.push({
        name: `${sanitizeFilename(settings.filename)}.scad`,
        content: scadContent
    });
    
    return await createZip(files);
}

function generateSCADFile(image: PartListImage, settings: OpenSCADSettings): string {
    const lines: string[] = [];
    
    lines.push('// Generated by firaga.io');
    lines.push('// OpenSCAD heightmap-based 3D pixel art');
    lines.push('');
    lines.push(`$fn = 20; // Circle resolution`);
    lines.push('');
    lines.push(`pitch = ${settings.pitch}; // mm per pixel`);
    lines.push(`height = ${settings.height}; // mm height`);
    lines.push(`img_width = ${image.width};`);
    lines.push(`img_height = ${image.height};`);
    lines.push('');
    
    // Function to create a heightmap-based extrusion
    lines.push('module pixel_layer(image_file, color) {');
    lines.push('    color(color)');
    lines.push('    linear_extrude(height = height)');
    lines.push('    scale([pitch, pitch, 1])');
    lines.push('    surface(file = image_file, center = false, invert = true);');
    lines.push('}');
    lines.push('');
    
    // Add each color layer
    for (let i = 0; i < image.partList.length; i++) {
        const color = image.partList[i];
        const hexColor = colorEntryToHex(color.target);
        const r = parseInt(hexColor.substring(1, 3), 16) / 255;
        const g = parseInt(hexColor.substring(3, 5), 16) / 255;
        const b = parseInt(hexColor.substring(5, 7), 16) / 255;
        
        const filename = `mask_${i}_${sanitizeFilename(color.target.name)}.png`;
        lines.push(`// ${color.target.name}`);
        lines.push(`pixel_layer("${filename}", [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}]);`);
        lines.push('');
    }
    
    return lines.join('\n');
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

async function createZip(files: Array<{ name: string; content: string }>): Promise<Blob> {
    const zip = new JSZip();
    
    for (const file of files) {
        if (file.name.endsWith('.png')) {
            // PNG files are base64 encoded
            zip.file(file.name, file.content, { base64: true });
        } else {
            // Text files (like .scad)
            zip.file(file.name, file.content);
        }
    }
    
    return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
}
