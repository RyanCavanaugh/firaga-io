import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

declare const JSZip: any;

export async function generateOpenSCADMasks(image: PartListImage, filename: string) {
    // Load JSZip library if not already loaded
    await loadJSZip();
    
    const zip = new JSZip();
    
    // Generate one monochrome image per color
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const color = image.partList[colorIndex];
        const maskImage = createMaskImage(image, colorIndex);
        zip.file(`mask_${colorIndex}_${sanitizeFilename(color.target.name)}.png`, maskImage.split(',')[1], { base64: true });
    }
    
    // Generate the OpenSCAD file
    const scadContent = generateOpenSCADFile(image);
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate the ZIP file
    const blob = await zip.generateAsync({ type: 'blob' });
    downloadBlob(blob, `${filename}_openscad.zip`);
}

function createMaskImage(image: PartListImage, colorIndex: number): string {
    // Create a canvas for the mask
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    
    // Fill with white background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, image.width, image.height);
    
    // Draw black pixels where this color exists
    ctx.fillStyle = 'black';
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            if (image.pixels[y][x] === colorIndex) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    return canvas.toDataURL('image/png');
}

function generateOpenSCADFile(image: PartListImage): string {
    let scad = '// OpenSCAD file generated by firaga.io\n';
    scad += '// This file creates a 3D representation of the pixel art image\n\n';
    
    scad += `image_width = ${image.width};\n`;
    scad += `image_height = ${image.height};\n`;
    scad += `pixel_size = 1; // mm per pixel\n`;
    scad += `layer_height = 2; // mm per color layer\n\n`;
    
    scad += '// Combine all color layers\n';
    scad += 'union() {\n';
    
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const color = image.partList[colorIndex];
        const colorName = sanitizeFilename(color.target.name);
        const hex = colorEntryToHex(color.target);
        
        scad += `  // Layer ${colorIndex}: ${color.target.name}\n`;
        scad += `  color("${hex}") {\n`;
        scad += `    translate([0, 0, ${colorIndex * 0.01}]) // Slight offset to avoid z-fighting\n`;
        scad += `    scale([pixel_size, pixel_size, layer_height])\n`;
        scad += `    surface(file = "mask_${colorIndex}_${colorName}.png", center = false, invert = true);\n`;
        scad += `  }\n`;
    }
    
    scad += '}\n';
    
    return scad;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_');
}

function downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

async function loadJSZip(): Promise<void> {
    return new Promise((resolve, reject) => {
        if (typeof JSZip !== 'undefined') {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load JSZip'));
        document.head.appendChild(script);
    });
}
