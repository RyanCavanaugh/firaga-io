import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";

declare const JSZip: typeof import("jszip");

/**
 * Generate a ZIP file containing:
 * - One monochrome PNG image per color (black pixels where that color appears)
 * - An OpenSCAD file that uses surface() to create heightmaps from the images
 */
export async function generateOpenSCADMasks(image: PartListImage, settings: OpenSCADSettings): Promise<Blob> {
    await loadJSZip();
    
    const zip = new JSZip();
    const { pixelHeight = 1, baseThickness = 0.5 } = settings;
    
    // Generate one mask image per color
    const imageFiles: string[] = [];
    
    for (let colorIndex = 0; colorIndex < image.partList.length; colorIndex++) {
        const part = image.partList[colorIndex];
        const filename = `color_${colorIndex}_${sanitizeFilename(part.target.name)}.png`;
        imageFiles.push(filename);
        
        // Create canvas for this color's mask
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with white (transparent in heightmap)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw black pixels where this color appears
        ctx.fillStyle = '#000000';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === colorIndex) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to blob and add to zip
        const blob = await canvasToBlob(canvas);
        zip.file(filename, blob);
    }
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, imageFiles, pixelHeight, baseThickness);
    zip.file('model.scad', scadContent);
    
    // Generate README
    const readme = `3D Model Export from firaga.io

This archive contains:
- model.scad: OpenSCAD file that generates the 3D model
- ${imageFiles.length} PNG mask files (one per color)

To use:
1. Open model.scad in OpenSCAD (https://openscad.org/)
2. Press F5 to preview or F6 to render
3. Export as STL for 3D printing

Colors are separated into individual layers that can be:
- Printed separately and assembled
- Combined in multi-material 3D printers
- Used as a reference for painting

Image size: ${image.width} x ${image.height} pixels
Colors: ${image.partList.length}
`;
    zip.file('README.txt', readme);
    
    return zip.generateAsync({ type: 'blob' });
}

function generateOpenSCADFile(image: PartListImage, imageFiles: readonly string[], pixelHeight: number, baseThickness: number): string {
    let scad = `// Generated by firaga.io
// Image: ${image.width} x ${image.height} pixels
// Colors: ${image.partList.length}

// Parameters
pixel_height = ${pixelHeight}; // Height of each colored pixel in mm
base_thickness = ${baseThickness}; // Thickness of base plate in mm
image_width = ${image.width};
image_height = ${image.height};

// Scale factor (1 pixel = 1mm by default)
scale_factor = 1;

`;
    
    // Add color definitions
    scad += `// Color definitions\n`;
    image.partList.forEach((part, index) => {
        const hex = colorEntryToHex(part.target).substring(1);
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        scad += `color_${index} = [${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}]; // ${part.target.name}\n`;
    });
    
    scad += `\n// Main model\n`;
    scad += `union() {\n`;
    
    // Add base plate
    if (baseThickness > 0) {
        scad += `  // Base plate\n`;
        scad += `  translate([0, 0, -base_thickness])\n`;
        scad += `    cube([image_width * scale_factor, image_height * scale_factor, base_thickness]);\n\n`;
    }
    
    // Add each color layer
    imageFiles.forEach((filename, index) => {
        const colorVar = `color_${index}`;
        scad += `  // Layer ${index + 1}: ${image.partList[index].target.name}\n`;
        scad += `  color(${colorVar})\n`;
        scad += `    scale([scale_factor, scale_factor, pixel_height])\n`;
        scad += `      surface(file = "${filename}", center = false, invert = true);\n\n`;
    });
    
    scad += `}\n`;
    
    return scad;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
}

async function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to convert canvas to blob'));
            }
        }, 'image/png');
    });
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
        return new Promise<void>((resolve, reject) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.onerror = () => reject(new Error('Failed to load JSZip'));
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}

export interface OpenSCADSettings {
    pixelHeight?: number;
    baseThickness?: number;
}
