import { PartListImage } from "./image-utils";

export type ExportOpenSCADSettings = {
    pixelSize: number;
    heightScale: number;
};

export async function generateOpenSCADMasks(image: PartListImage, settings: ExportOpenSCADSettings): Promise<Blob> {
    const { pixelSize, heightScale } = settings;
    
    // Generate one image per color
    const imagePromises = image.partList.map(async (part, idx) => {
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d')!;
        
        // Fill with black background
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, image.width, image.height);
        
        // Draw white pixels where this color exists
        ctx.fillStyle = '#FFFFFF';
        for (let y = 0; y < image.height; y++) {
            for (let x = 0; x < image.width; x++) {
                if (image.pixels[y][x] === idx) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        // Convert canvas to PNG blob
        const blob = await new Promise<Blob>((resolve) => {
            canvas.toBlob((b) => resolve(b!), 'image/png');
        });
        
        const sanitizedName = sanitizeFilename(part.target.name);
        return { filename: `mask_${idx}_${sanitizedName}.png`, blob };
    });
    
    const images = await Promise.all(imagePromises);
    
    // Generate OpenSCAD file
    const scadContent = generateSCADFile(image, images.map(img => img.filename), settings);
    const scadBlob = new Blob([scadContent], { type: 'text/plain' });
    
    // Create ZIP file containing all images and the SCAD file
    return createZipArchive([
        ...images,
        { filename: 'pixel_art.scad', blob: scadBlob }
    ]);
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}

function generateSCADFile(image: PartListImage, maskFilenames: string[], settings: ExportOpenSCADSettings): string {
    const { pixelSize, heightScale } = settings;
    
    const modules = image.partList.map((part, idx) => {
        const filename = maskFilenames[idx];
        
        return `module layer_${idx}() {
    // Use surface to create heightmap from mask image
    // surface() reads grayscale values (0-255) as heights
    scale([${pixelSize}, ${pixelSize}, ${heightScale / 255}])
    translate([-${image.width / 2}, -${image.height / 2}, 0])
    surface(file = "${filename}", center = false, invert = false);
}`;
    }).join('\n\n');
    
    const calls = image.partList.map((part, idx) => {
        return `color("${rgbToOpenSCAD(part.target.r, part.target.g, part.target.b)}") layer_${idx}();`;
    }).join('\n');
    
    return `// Pixel Art 3D Model
// Generated by firaga.io
// Image size: ${image.width} x ${image.height} pixels
// Pixel size: ${pixelSize} mm
// Height scale: ${heightScale} mm

${modules}

// Render all layers with their colors
${calls}
`;
}

function rgbToOpenSCAD(r: number, g: number, b: number): string {
    return `${(r / 255).toFixed(3)}, ${(g / 255).toFixed(3)}, ${(b / 255).toFixed(3)}`;
}

async function createZipArchive(files: { filename: string; blob: Blob }[]): Promise<Blob> {
    const zipParts: Uint8Array[] = [];
    const centralDirectory: Uint8Array[] = [];
    let offset = 0;

    for (const file of files) {
        const data = new Uint8Array(await file.blob.arrayBuffer());
        const { localHeader, centralHeader, compressedData } = createZipEntry(file.filename, data, offset);
        zipParts.push(localHeader, compressedData);
        centralDirectory.push(centralHeader);
        offset += localHeader.length + compressedData.length;
    }

    const endOfCentral = createEndOfCentralDirectory(files.length, centralDirectory, offset);
    
    return new Blob([...zipParts, ...centralDirectory, endOfCentral], { type: 'application/zip' });
}

function createZipEntry(filename: string, data: Uint8Array, offset: number) {
    const filenameBytes = new TextEncoder().encode(filename);
    const crc = crc32(data);
    
    const localHeader = new Uint8Array(30 + filenameBytes.length);
    const view = new DataView(localHeader.buffer);
    
    // Local file header signature
    view.setUint32(0, 0x04034b50, true);
    // Version needed to extract
    view.setUint16(4, 20, true);
    // General purpose bit flag
    view.setUint16(6, 0, true);
    // Compression method (0 = no compression)
    view.setUint16(8, 0, true);
    // File last modification time
    view.setUint16(10, 0, true);
    // File last modification date
    view.setUint16(12, 0, true);
    // CRC-32
    view.setUint32(14, crc, true);
    // Compressed size
    view.setUint32(18, data.length, true);
    // Uncompressed size
    view.setUint32(22, data.length, true);
    // File name length
    view.setUint16(26, filenameBytes.length, true);
    // Extra field length
    view.setUint16(28, 0, true);
    // File name
    localHeader.set(filenameBytes, 30);
    
    const centralHeader = new Uint8Array(46 + filenameBytes.length);
    const centralView = new DataView(centralHeader.buffer);
    
    // Central directory file header signature
    centralView.setUint32(0, 0x02014b50, true);
    // Version made by
    centralView.setUint16(4, 20, true);
    // Version needed to extract
    centralView.setUint16(6, 20, true);
    // General purpose bit flag
    centralView.setUint16(8, 0, true);
    // Compression method
    centralView.setUint16(10, 0, true);
    // File last modification time
    centralView.setUint16(12, 0, true);
    // File last modification date
    centralView.setUint16(14, 0, true);
    // CRC-32
    centralView.setUint32(16, crc, true);
    // Compressed size
    centralView.setUint32(20, data.length, true);
    // Uncompressed size
    centralView.setUint32(24, data.length, true);
    // File name length
    centralView.setUint16(28, filenameBytes.length, true);
    // Extra field length
    centralView.setUint16(30, 0, true);
    // File comment length
    centralView.setUint16(32, 0, true);
    // Disk number start
    centralView.setUint16(34, 0, true);
    // Internal file attributes
    centralView.setUint16(36, 0, true);
    // External file attributes
    centralView.setUint32(38, 0, true);
    // Relative offset of local header
    centralView.setUint32(42, offset, true);
    // File name
    centralHeader.set(filenameBytes, 46);
    
    return { localHeader, centralHeader, compressedData: data };
}

function createEndOfCentralDirectory(fileCount: number, centralDirectory: Uint8Array[], centralDirOffset: number): Uint8Array {
    const centralDirSize = centralDirectory.reduce((sum, arr) => sum + arr.length, 0);
    const end = new Uint8Array(22);
    const view = new DataView(end.buffer);
    
    // End of central directory signature
    view.setUint32(0, 0x06054b50, true);
    // Number of this disk
    view.setUint16(4, 0, true);
    // Disk where central directory starts
    view.setUint16(6, 0, true);
    // Number of central directory records on this disk
    view.setUint16(8, fileCount, true);
    // Total number of central directory records
    view.setUint16(10, fileCount, true);
    // Size of central directory
    view.setUint32(12, centralDirSize, true);
    // Offset of start of central directory
    view.setUint32(16, centralDirOffset, true);
    // Comment length
    view.setUint16(20, 0, true);
    
    return end;
}

function crc32(data: Uint8Array): number {
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < data.length; i++) {
        crc = crc32Table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
}

const crc32Table = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
    let c = i;
    for (let j = 0; j < 8; j++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    crc32Table[i] = c;
}
