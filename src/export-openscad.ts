import { saveAs } from 'file-saver';
import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';

// Using dynamic import for JSZip since it's not in package.json yet
declare const JSZip: any;

export interface ExportOpenSCADSettings {
    filename: string;
    pixelSize: number;
    heightPerColor: number;
}

/**
 * Exports a PartListImage as a zip containing OpenSCAD masks:
 * - One black/white PNG per color
 * - An OpenSCAD file that loads and combines them
 */
export async function exportOpenSCADMasks(image: PartListImage, settings: ExportOpenSCADSettings): Promise<void> {
    await loadJSZip();
    
    const zip = new JSZip();
    const { filename, pixelSize, heightPerColor } = settings;
    
    // Generate one mask image per color
    const imageFiles: Array<{ name: string; colorName: string; height: number }> = [];
    
    for (let partIdx = 0; partIdx < image.partList.length; partIdx++) {
        const part = image.partList[partIdx];
        const maskCanvas = createMaskImage(image, partIdx);
        const imageName = `mask_${partIdx}_${sanitizeFilename(part.target.name)}.png`;
        
        const blob = await canvasToBlob(maskCanvas);
        zip.file(imageName, blob);
        
        imageFiles.push({
            name: imageName,
            colorName: part.target.name,
            height: heightPerColor * (partIdx + 1)
        });
    }
    
    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(imageFiles, image.width, image.height, pixelSize);
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate and save the zip
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    saveAs(zipBlob, `${filename}_openscad.zip`);
}

/**
 * Creates a black and white mask image for a specific color
 */
function createMaskImage(image: PartListImage, partIdx: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Could not get canvas context');
    }
    
    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const pixelPartIdx = image.pixels[y][x];
            const idx = (y * image.width + x) * 4;
            
            // White (255) where this color appears, black (0) elsewhere
            const value = pixelPartIdx === partIdx ? 255 : 0;
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A (fully opaque)
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}

/**
 * Generates the OpenSCAD file content
 */
function generateOpenSCADFile(
    imageFiles: Array<{ name: string; colorName: string; height: number }>,
    width: number,
    height: number,
    pixelSize: number
): string {
    const scadLines: string[] = [];
    
    scadLines.push('// Generated by firaga.io');
    scadLines.push('// 3D pixel art using surface heightmaps from mask images');
    scadLines.push('');
    scadLines.push(`pixel_size = ${pixelSize};`);
    scadLines.push(`image_width = ${width};`);
    scadLines.push(`image_height = ${height};`);
    scadLines.push('');
    
    scadLines.push('union() {');
    
    imageFiles.forEach(({ name, colorName }, idx) => {
        scadLines.push(`  // Layer ${idx + 1}: ${colorName}`);
        scadLines.push(`  translate([0, 0, ${idx * pixelSize}])`);
        scadLines.push(`    scale([pixel_size, pixel_size, pixel_size])`);
        scadLines.push(`      surface(file = "${name}", center = true, invert = true);`);
        scadLines.push('');
    });
    
    scadLines.push('}');
    
    return scadLines.join('\n');
}

function sanitizeFilename(name: string): string {
    return name
        .replace(/[^a-zA-Z0-9_-]/g, '_')
        .replace(/_+/g, '_')
        .toLowerCase();
}

function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob from canvas'));
            }
        }, 'image/png');
    });
}

async function loadJSZip(): Promise<void> {
    const tagName = 'jszip-script-tag';
    const scriptEl = document.getElementById(tagName);
    
    if (scriptEl !== null) {
        // Already loaded
        return;
    }
    
    return new Promise((resolve, reject) => {
        const tag = document.createElement('script');
        tag.id = tagName;
        tag.onload = () => resolve();
        tag.onerror = () => reject(new Error('Failed to load JSZip'));
        tag.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        document.head.appendChild(tag);
    });
}
