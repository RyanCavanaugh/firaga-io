import { PartListImage } from './image-utils';
import { colorEntryToHex } from './utils';
import JSZip from 'jszip';

/**
 * Generates an OpenSCAD masks zip file from a PartListImage
 * Contains: one B/W PNG per color + an .scad file that loads them
 */
export async function generateOpenSCADMasks(image: PartListImage, filename: string): Promise<Blob> {
    const zip = new JSZip();

    // Generate one mask image per color
    const maskPromises = image.partList.map(async (part, idx) => {
        const maskImage = await createMaskImage(image, idx);
        const colorName = sanitizeFilename(part.target.name);
        zip.file(`mask_${idx}_${colorName}.png`, maskImage);
        return { idx, colorName, hex: colorEntryToHex(part.target) };
    });

    const maskInfos = await Promise.all(maskPromises);

    // Generate OpenSCAD file
    const scadContent = generateOpenSCADFile(image, maskInfos, filename);
    zip.file(`${sanitizeFilename(filename)}.scad`, scadContent);

    // Generate ZIP archive
    return await zip.generateAsync({ type: 'blob' });
}

/**
 * Creates a black and white mask image for a specific color index
 */
async function createMaskImage(image: PartListImage, colorIndex: number): Promise<Blob> {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        throw new Error('Failed to get canvas context');
    }

    const imageData = ctx.createImageData(image.width, image.height);
    
    for (let y = 0; y < image.height; y++) {
        for (let x = 0; x < image.width; x++) {
            const pixelColorIndex = image.pixels[y][x];
            const offset = (y * image.width + x) * 4;
            
            // White (255) where this color exists, black (0) elsewhere
            const value = pixelColorIndex === colorIndex ? 255 : 0;
            imageData.data[offset] = value;     // R
            imageData.data[offset + 1] = value; // G
            imageData.data[offset + 2] = value; // B
            imageData.data[offset + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return new Promise<Blob>((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create blob from canvas'));
            }
        }, 'image/png');
    });
}

/**
 * Generates the OpenSCAD file content
 */
function generateOpenSCADFile(
    image: PartListImage,
    maskInfos: Array<{ idx: number; colorName: string; hex: string }>,
    filename: string
): string {
    let scad = `// Generated by firaga.io for ${filename}\n`;
    scad += `// Image size: ${image.width}x${image.height}\n\n`;
    
    scad += `// Configuration\n`;
    scad += `voxel_size = 1; // Size of each pixel/bead in mm\n`;
    scad += `layer_height = 1; // Height of each color layer in mm\n`;
    scad += `total_height = ${maskInfos.length} * layer_height;\n\n`;

    scad += `// Color definitions (RGB normalized 0-1)\n`;
    maskInfos.forEach(({ idx, colorName, hex }) => {
        const rgb = hexToRgb(hex);
        scad += `color_${idx} = [${rgb.r / 255}, ${rgb.g / 255}, ${rgb.b / 255}]; // ${colorName}\n`;
    });
    scad += '\n';

    scad += `module create_layer(mask_file, color_rgb, z_offset) {\n`;
    scad += `  color(color_rgb)\n`;
    scad += `  translate([0, 0, z_offset])\n`;
    scad += `  scale([voxel_size, voxel_size, layer_height])\n`;
    scad += `  surface(file=mask_file, center=true, invert=true);\n`;
    scad += `}\n\n`;

    scad += `// Build the complete model\n`;
    scad += `union() {\n`;
    maskInfos.forEach(({ idx, colorName }) => {
        scad += `  create_layer("mask_${idx}_${colorName}.png", color_${idx}, ${idx} * layer_height);\n`;
    });
    scad += `}\n`;

    return scad;
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
    // Remove # if present
    hex = hex.replace(/^#/, '');
    
    const bigint = parseInt(hex, 16);
    return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
    };
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
}
