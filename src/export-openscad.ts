import { PartListImage } from "./image-utils";
import { colorEntryToHex } from "./utils";
import { Export3DSettings } from "./export-3d-types";

/**
 * Generate an OpenSCAD masks format as multiple files
 * Contains one monochrome image per color and an .scad file that loads them
 */
export async function generateOpenSCADMasks(
    image: PartListImage,
    settings: Export3DSettings
): Promise<Array<{ filename: string; blob: Blob }>> {
    const { width, height, pixels, partList } = image;
    const { pixelHeight, baseHeight } = settings;
    
    // Generate one black/white PNG per color
    const imageMasks: Array<{ filename: string; blob: Blob; colorName: string }> = [];
    
    for (let partIndex = 0; partIndex < partList.length; partIndex++) {
        const part = partList[partIndex];
        const maskImage = createMaskImage(width, height, pixels, partIndex);
        const blob = await canvasToBlob(maskImage);
        const filename = `color_${partIndex}_${sanitizeFilename(part.target.name)}.png`;
        imageMasks.push({ filename, blob, colorName: part.target.name });
    }
    
    // Generate the OpenSCAD file
    const scadContent = generateSCADFile(imageMasks, width, height, pixelHeight, baseHeight, partList);
    
    // Return all files to download
    return createZipBlob(imageMasks, scadContent);
}

function createMaskImage(
    width: number,
    height: number,
    pixels: ReadonlyArray<ReadonlyArray<number>>,
    partIndex: number
): HTMLCanvasElement {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Could not get canvas context");
    
    const imageData = ctx.createImageData(width, height);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            // White (255) where this color is present, black (0) elsewhere
            const value = pixels[y][x] === partIndex ? 255 : 0;
            imageData.data[idx] = value;     // R
            imageData.data[idx + 1] = value; // G
            imageData.data[idx + 2] = value; // B
            imageData.data[idx + 3] = 255;   // A
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}

function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error("Failed to convert canvas to blob"));
            }
        }, "image/png");
    });
}

function generateSCADFile(
    masks: Array<{ filename: string; colorName: string }>,
    width: number,
    height: number,
    pixelHeight: number,
    baseHeight: number,
    partList: PartListImage["partList"]
): string {
    let scadCode = `// Generated by firaga.io
// Image dimensions: ${width}x${height}

// Parameters
pixel_height = ${pixelHeight};
base_height = ${baseHeight};
image_width = ${width};
image_height = ${height};

// Base plate
color([0.8, 0.8, 0.8])
translate([0, 0, 0])
cube([image_width, image_height, base_height]);

`;
    
    masks.forEach(({ filename, colorName }, idx) => {
        const part = partList[idx];
        const hex = colorEntryToHex(part.target).substring(1); // Remove #
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        
        scadCode += `// ${colorName}\n`;
        scadCode += `color([${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}])\n`;
        scadCode += `translate([0, 0, base_height])\n`;
        scadCode += `scale([1, 1, pixel_height])\n`;
        scadCode += `surface(file = "${filename}", center = false, invert = true);\n\n`;
    });
    
    return scadCode;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, "_").toLowerCase();
}

async function createZipBlob(
    images: Array<{ filename: string; blob: Blob }>,
    scadContent: string
): Promise<Array<{ filename: string; blob: Blob }>> {
    // Return array of files to download separately
    // Browser doesn't support creating zip files without a library
    const files: Array<{ filename: string; blob: Blob }> = [...images];
    files.push({
        filename: "design.scad",
        blob: new Blob([scadContent], { type: "text/plain" })
    });
    return files;
}

export async function downloadOpenSCADMasks(
    image: PartListImage,
    settings: Export3DSettings
): Promise<void> {
    const files = await generateOpenSCADMasks(image, settings);
    
    // Download each file separately
    files.forEach(({ filename, blob }) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${settings.filename}_${filename}`;
        a.click();
        URL.revokeObjectURL(url);
    });
}
