import { saveAs } from 'file-saver';
import { PartListImage } from '../image-utils';
import { colorEntryToHex } from '../utils';

// Declare JSZip type from global
declare const JSZip: any;

export async function generateOpenSCADMasks(image: PartListImage, filename: string): Promise<void> {
    await loadJSZip();
    
    const zip = new JSZip();
    const scadLines: string[] = [];
    
    scadLines.push('// Generated by firaga.io');
    scadLines.push('// OpenSCAD heightmap-based 3D display');
    scadLines.push('');
    scadLines.push(`image_width = ${image.width};`);
    scadLines.push(`image_height = ${image.height};`);
    scadLines.push('pixel_size = 1;');
    scadLines.push('pixel_height = 1;');
    scadLines.push('');
    
    // Generate a mask image for each color
    for (let colorIdx = 0; colorIdx < image.partList.length; colorIdx++) {
        const entry = image.partList[colorIdx];
        const maskFilename = `mask_${colorIdx}_${sanitizeFilename(entry.target.name)}.png`;
        
        // Create monochrome PNG for this color
        const canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext('2d');
        
        if (ctx) {
            // Fill with white (background)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, image.width, image.height);
            
            // Draw black pixels where this color appears
            ctx.fillStyle = '#000000';
            for (let y = 0; y < image.height; y++) {
                for (let x = 0; x < image.width; x++) {
                    if (image.pixels[y][x] === colorIdx) {
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            // Convert canvas to blob
            const blob = await new Promise<Blob>((resolve) => {
                canvas.toBlob((b) => resolve(b!), 'image/png');
            });
            
            zip.file(maskFilename, blob);
            
            // Add to OpenSCAD file
            const colorHex = colorEntryToHex(entry.target);
            const [r, g, b] = hexToRgb(colorHex);
            
            scadLines.push(`// ${entry.target.name} (${entry.count} pixels)`);
            scadLines.push(`color([${r}, ${g}, ${b}])`);
            scadLines.push(`    surface(file = "${maskFilename}", center = true, invert = true);`);
            scadLines.push('');
        }
    }
    
    // Create the OpenSCAD file
    const scadContent = scadLines.join('\n');
    zip.file(`${filename}.scad`, scadContent);
    
    // Generate and download the ZIP
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    saveAs(zipBlob, `${filename}_openscad.zip`);
}

async function loadJSZip(): Promise<void> {
    const tagName = "jszip-script-tag";
    const scriptEl = document.getElementById(tagName);
    
    if (scriptEl === null) {
        return new Promise((resolve) => {
            const tag = document.createElement("script");
            tag.id = tagName;
            tag.onload = () => resolve();
            tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            document.head.appendChild(tag);
        });
    }
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
}

function hexToRgb(hex: string): [number, number, number] {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        return [
            parseInt(result[1], 16) / 255,
            parseInt(result[2], 16) / 255,
            parseInt(result[3], 16) / 255
        ];
    }
    return [0, 0, 0];
}
